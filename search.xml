<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo文章加密</title>
      <link href="/xingliu-test/2024/06/07/Hexo%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86/"/>
      <url>/xingliu-test/2024/06/07/Hexo%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>以下文章来源于<a href="https://luochunhai.github.io/2021/09/23/frontend/hexo/hexo-encrypt/#:~:text=%E5%8F%AA%E9%9C%80%E8%A6%81%E5%9C%A8%E9%9C%80%E8%A6%81%E5%8A%A0%E5%AF%86%E7%9A%84%E6%96%87%E7%AB%A0%E4%B8%AD%EF%BC%8C%E6%B7%BB%E5%8A%A0%E8%AE%BE%E7%BD%AE%E7%9A%84%20tag%E5%80%BC%20%E5%8D%B3%E5%8F%AF%E3%80%82%20%E5%9C%A8Hexo%E4%B8%BB%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%20_config.yml%20%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%A6%82%E4%B8%8B%E9%85%8D%E7%BD%AE%EF%BC%9A,12345678910%20%23%20Securityencrypt%3A%20%23%20hexo-blog-encryptsilent%3A%20trueabstract%3A%20%E8%BF%99%E6%98%AF%E4%B8%80%E7%AF%87%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0%EF%BC%8C%E9%9C%80%E8%A6%81%E5%AF%86%E7%A0%81%E6%89%8D%E8%83%BD%E7%BB%A7%E7%BB%AD%E9%98%85%E8%AF%BB%E3%80%82">hexo 加密</a>，为防止丢失和方便查看，进行了内容的搬运</p><h6 id="插件安装-快速使用"><a href="#插件安装-快速使用" class="headerlink" title="插件安装 &amp; 快速使用"></a>插件安装 &amp; 快速使用</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-blog-encrypt <span class="comment"># 安装插件</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line"><span class="built_in">date</span>: 2021-04-13 21:18:02</span><br><span class="line">password: hello</span><br><span class="line">---</span><br><span class="line"><span class="comment"># 添加password字段</span></span><br></pre></td></tr></table></figure><h6 id="全局加密配置"><a href="#全局加密配置" class="headerlink" title="全局加密配置"></a>全局加密配置</h6><p>分别为每篇文章设置密码，虽然很灵活，但是配置或者修改起来非常麻烦。为此，可以通过设置统一配置来实现全局加密。<br>通过添加指定 tag 的方式，可以为所有需要加密的文章添加统一加密操作。只需要在需要加密的文章中，添加设置的 tag值 即可。<br>在Hexo主配置文件 _config.yml 中添加如下配置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Security</span></span><br><span class="line">encrypt: <span class="comment"># hexo-blog-encrypt</span></span><br><span class="line">silent: <span class="literal">true</span></span><br><span class="line">abstract: 这是一篇加密文章，需要密码才能继续阅读。</span><br><span class="line">message: 当前文章暂不对外可见，请输入密码后查看！</span><br><span class="line">tags:</span><br><span class="line">- &#123;name: private, password: hello&#125;</span><br><span class="line">wrong_pass_message: 抱歉，您输入的密码错误，请检查后重新输入。</span><br><span class="line">wrong_hash_message: 抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>其中的 tag 部分：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tags:</span><br><span class="line">- &#123;name: private, password: hello&#125;</span><br></pre></td></tr></table></figure><p>表示当在文章中指定了 private 这个 tag 后，该文章就会自动加密并使用对应的值 hello 作为密码，输入密码后才可查看。<br>相应的文章头部设置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Password Test</span><br><span class="line"><span class="built_in">date</span>: 2019-12-21 11:54:07</span><br><span class="line">tags:</span><br><span class="line">- private</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>在全局加密配置下禁用某些文章的加密<br>可能有这样的情况，属于 private 标签下的某篇文章在一段时间内想要开放访问。如果在描述中加上密码提示： 当前文章密码为xxx，请输入密码后查看 ，来让用户每次查看时都要先输入密码后再查看，这样的操作又会给访客带来不便。<br>这时可以单独设置允许某篇文章不设置密码。<br>只需要在使用 加密tag 的前提下，结合 password 来实现即可。在博客文章的头部添加 password 并设置为 “” 就能取消当前文章的 Tag 加密。<br>相应的设置示例如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: No Password Test</span><br><span class="line"><span class="built_in">date</span>: 2019-12-21 11:54:07</span><br><span class="line">tags:</span><br><span class="line">- private</span><br><span class="line">password: <span class="string">&quot;&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure><h6 id="在全局加密配置下设置非全局密码"><a href="#在全局加密配置下设置非全局密码" class="headerlink" title="在全局加密配置下设置非全局密码"></a>在全局加密配置下设置非全局密码</h6><p>在全局加密配置下，我们可以通过设置多个 加密tag 来为多篇不同类型的文章设置相同的查看密码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tags:</span><br><span class="line">- &#123;name: private, password: hello&#125;</span><br><span class="line">- &#123;name: jiami, password: world&#125;</span><br><span class="line">- &#123;name: 加密, password: jiesuo&#125;</span><br></pre></td></tr></table></figure><p>那么可能有这样的场景：<br>属于 private 标签下的某篇文章想要设置成不一样的密码，防止用户恶意通过一个密码来查看同标签下的所有文章。此时，仍可以通过 password 参数来实现：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Password Test</span><br><span class="line"><span class="built_in">date</span>: 2019-12-21 11:54:07</span><br><span class="line">tags:</span><br><span class="line">- private</span><br><span class="line">password: <span class="string">&quot;buyiyang&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>说明：<br>该文章通过tag值 private 做了加密，按说密码应该为 hello ，但是又在信息头中设置了 password ，因为配置的优先级是 文章信息头 &gt; 按标签加密，所以最后的密码为 buyiyang 。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo创建&amp;迁移</title>
      <link href="/xingliu-test/2024/06/07/Hexo%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%81%E7%A7%BB/"/>
      <url>/xingliu-test/2024/06/07/Hexo%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%81%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>最近找到了实习，过几天去上班，所以也就闲下来了一些。想着我搞个博客吧，于是就开始了<br>本来是没想记录这个过程的，不过手贱把环境删除了，又得重来，正好就记录下（还好历史记录都在）<br>顺便可以为将来换服务器进行Hexo博客迁移做记录</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>我是拿云服务器进行部署的，网上通常是<code>Hexo + GitHubPage</code>，利用GitHub进行代码托管。时间仓促，就简单进行部署，博客内容使用<code>.md</code>文件编辑后添加到服务器。</p><ul><li>Nodejs：v14.17.6</li><li>Git：自己看着下</li><li>npm：一般Nodejs自带</li></ul><p>安装完成后，使用命令进行测试：<code>node -v</code>，<code>npm -v</code>，<code>git --version</code><br>GitHub：暂时用不到，跳过</p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>创建好你要放博客的目录，命令行中输入：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>但是这个会出现一些权限问题，具体自己看，可以换以下命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli --unsafe-perm</span><br></pre></td></tr></table></figure><p>安装成功后，以下命令进行测试</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo -version</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1717751384100-b2efb149-6964-4fcc-bc4b-d153b727a563.png#averageHue=%232d2c2c&clientId=u5fb26f2d-df60-4&from=paste&height=427&id=uc2837c05&originHeight=641&originWidth=691&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=44943&status=done&style=none&taskId=u7f90d561-5c2d-4feb-84ef-6650d9c90a7&title=&width=460.6666666666667" alt="image.png"></p><h3 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h3><p>进入博客目录，进行初始化，网络问题，可能会有点久，耐心等待</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init <span class="comment"># 初始化hexo，如果不行在命令后面添加 --unsafe-perm</span></span><br><span class="line">npm install <span class="comment"># 安装组件</span></span><br></pre></td></tr></table></figure><p>这个相当于是从代码仓库克隆后，进行了依赖安装<br>命令介绍：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 清理public文件夹</span></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译文件，生成public文件夹</span></span><br><span class="line">hexo g</span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行项目</span></span><br><span class="line">hexo server</span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署项目 我没用过</span></span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li>默认使用4000端口，也可以使用命令<code>hexo server -p port</code>进行修改</li><li>一般来说，上传文件后需要运行前三个命令进行重新编译，否则修改不生效</li></ul><p>基本上经过以上步骤就可以跑起来啦</p><h3 id="ButterFly主题"><a href="#ButterFly主题" class="headerlink" title="ButterFly主题"></a>ButterFly主题</h3><p>初始状态真的很丑，我们来改造一下<br>其中有很多帮助来源于一下两篇文章，由于在初创期间焦头烂额，大多数文章记录没有保存，走了很多弯路，现在来描述也不会很清晰，具体还是看这两篇文章吧<br><a href="https://butterfly.js.org/">Butterfly</a><br><a href="https://blog.csdn.net/mjh1667002013/article/details/129290903">【Hexo】Hexo搭建Butterfly主题并快速美化_hexo主题butterfly配置-CSDN博客</a></p><ol><li><p>我们先在hexo项目进行下载主题吧</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure></li><li><p>安装pug 和 stylus 渲染器。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure></li><li><p>修改项目根目录下的_config.yml文件（称为站点配置文件），开启主题</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line">theme: butterfly</span><br></pre></td></tr></table></figure><p>注意点：</p></li></ol><ul><li>下载主题后将整个主题文件放在<code>themes</code>文件夹下</li><li>后面就是一些配置，推荐把主题<code>butterfly</code>文件夹下的内容_config.yml进行复制，在博客根目录下创建_config.butterfly.yml，把内容粘贴进去，这个文件的内容，重复的会覆盖其它配置文件（原文件都不要删除）</li><li>注意里面有一些<code>tag</code>，<code>categories</code>，<code>archives</code>等文件，注意这几个文件是特有的</li><li>推荐后续在这些中进行修改，效果可以看前面两个文章<blockquote><p>敲黑板：只要改配置就要进行<code>hexo generate</code>命令后进行run，否则不生效<br>主题配置需要的话可以看名片加我细嗦</p></blockquote></li></ul><h3 id="Hexo原理"><a href="#Hexo原理" class="headerlink" title="Hexo原理"></a>Hexo原理</h3><p>对于page，你需要利用以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>会出现source&#x2F;categories&#x2F;index.md文件，在这个里面有一些配置<br>对于post，类似命令进行创建或者自动创建<code>.md</code>文件上传，但是需要以下参数（部分必须）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 必须 post的标题来源这里</span><br><span class="line"><span class="built_in">date</span>:</span><br><span class="line">updated:</span><br><span class="line"><span class="built_in">type</span>: </span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top_img:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aside:</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">random:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>参考这个博客吧<br><a href="https://butterfly.js.org/posts/dc584b87/#Front-matter">Butterfly 安裝文檔(二) 主題頁面</a></p><h3 id="Hexo迁移"><a href="#Hexo迁移" class="headerlink" title="Hexo迁移"></a>Hexo迁移</h3><ol><li>压缩原项目后上传</li><li>准备环境</li><li>安装必要的插件</li><li>正常跑起来就可以了</li></ol>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识</title>
      <link href="/xingliu-test/2024/06/05/JAVA/"/>
      <url>/xingliu-test/2024/06/05/JAVA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Java-C"><a href="#Java-C" class="headerlink" title="Java &amp; C++"></a>Java &amp; C++</h3><ul><li>内存管理：Java有自动的垃圾回收机制，C++需要手动管理</li><li>可移植性：Java在各个平台都可用，移植性好</li><li>安全性：Java具有强大的安全机制，字节码验证、访问控制等</li><li>性能：Java性能一般来说稍低一些</li></ul><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><p>Java 中将实参传递给方法（或函数）的方式是 <strong>值传递</strong>：</p><ul><li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li><li>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。</li></ul><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><ul><li><strong>序列化</strong>：将数据结构或对象转换成二进制字节流的过程</li><li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li></ul><p>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中<br />JDK自带序列化，实现 java.io.Serializable 接口即可<br />serialVersionUID：用于反序列化时检查是否一致的版本号，不一致就报错<br />使用 transient 进行阻止序列化<br />static修饰的变量不会被序列化<br />序列化方式：</p><ol><li>Java对象序列化</li><li>JSON序列化，通过ObjectMapper进行序列化</li><li>ProtoBuff 序列化</li></ol><h3 id="自动拆箱-装箱"><a href="#自动拆箱-装箱" class="headerlink" title="自动拆箱&#x2F;装箱"></a>自动拆箱&#x2F;装箱</h3><p>装箱：将基本类型⽤它们对应的引⽤类型包装起来； <br />拆箱：将包装类型转换为基本数据类型；</p><h3 id="面向过程和面向对象"><a href="#面向过程和面向对象" class="headerlink" title="面向过程和面向对象"></a>面向过程和面向对象</h3><p>面向过程：把解决问题的过程分为多个步骤，分别实现每个步骤后再调用解决问题<br />面向对象：抽象出问题的共同实体，为实体编写会产生的行为，解决问题时调用对象功能即可</p><h3 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h3><p>封装：抽取实体的共同属性，封装成对象，提供方法对外暴露属性操作方法<br />继承：子类继承父类的属性方法，并扩展出自己的特有属性方法<br />多态：运行时确定，引用指向的实例对象与编译时类不一致</p><h3 id="重载-重写"><a href="#重载-重写" class="headerlink" title="重载 &amp; 重写"></a>重载 &amp; 重写</h3><p>重载：一个类中的同名方法改写，修改参数特征保证方法调用不同<br />重写：子类对父类方法的重写，方法名和参数类型等都得一致，抛出异常不能大于父类方法，方法可见范围不能大于父类方法</p><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>this 是⾃⾝的⼀个对象，代表对象本⾝，可以理解为：指向对象本⾝的⼀个指针</p><ol><li>普通的直接引⽤，this 相当于是指向当前对象本⾝</li><li>形参与成员变量名字重名，⽤ this 来区分</li><li>引⽤本类的构造函数</li></ol><h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><p><strong>共同点</strong>：</p><ul><li>都不能被实例化。</li><li>都可以包含抽象方法。</li><li>都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）。</li></ul><p><strong>区别</strong>：</p><ul><li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li></ul><h3 id="理解-String-类型值的不可变"><a href="#理解-String-类型值的不可变" class="headerlink" title="理解 String 类型值的不可变"></a>理解 String 类型值的不可变</h3><p>首先String是不可继承的，其次存储数据的value数组是使用final修饰的</p><ul><li>多线程下更安全</li><li>保证哈希值的唯一性和一致性</li><li>修改时不是直接修改String对象，性能更好</li><li>字符串常量池共用字符串，如果可变会出现问题</li></ul><h3 id="Java创建对象的方式"><a href="#Java创建对象的方式" class="headerlink" title="Java创建对象的方式"></a>Java创建对象的方式</h3><ol><li>new关键字</li><li>反射机制</li><li>clone机制</li><li>序列化方式</li></ol><h3 id="讲讲你对反射的理解"><a href="#讲讲你对反射的理解" class="headerlink" title="讲讲你对反射的理解"></a>讲讲你对反射的理解</h3><p>反射是Java语言的一个特性，它允许程序在运行时，对于任意一个类，都能够知道这个类的所有属性和方法,对于任意一个对象，都能够调用它的任意方法和属性,这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。<br />原理：类在加载完成后会生成一个Class对象，我们平常的话都是通过new关键字调用这个对象来获取属性和方法，属于是硬编码，反射就有程序员来指定要加载哪些属性和方法。<br />应用：动态配置，Spring AOP，IOC容器，最具体的就是数据库连接根据不同的驱动通过反射来创建不同的连接对象。如果对于一个集合的类型存在改变，今天HashMap，明天LinkedHashMap，你大可以用选择分支来判断使用那个进行new出来，但是你也可以使用反射，传类的全限定名来动态获取属性和方法。</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton1 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton1</span>();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>抽象策略类；具体策略类；环境类<br />定义抽象策略类接口和环境类，环境类包括抽象策略和策略调用方法，具体策略类是具体策略实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyPattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">        <span class="type">Strategy</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>();</span><br><span class="line">        c.setStrategy(s);</span><br><span class="line">        c.strategyMethod();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        s = <span class="keyword">new</span> <span class="title class_">ConcreteStrategyB</span>();</span><br><span class="line">        c.setStrategy(s);</span><br><span class="line">        c.strategyMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象策略类</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">strategyMethod</span><span class="params">()</span>;    <span class="comment">//策略方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体策略类A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">strategyMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体策略A的策略方法被访问！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体策略类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">strategyMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体策略B的策略方法被访问！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    <span class="keyword">public</span> Strategy <span class="title function_">getStrategy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrategy</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">strategyMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        strategy.strategyMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样还是没有消除if-else以及策略类过多的问题<br />可以使用枚举类+Map</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    A&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exe</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行具体策略A&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    B&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">exe</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行具体策略B&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">exe</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Strategy&gt; map=<span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;A&quot;</span>,Strategy.A);</span><br><span class="line">        map.put(<span class="string">&quot;B&quot;</span>,Strategy.B);</span><br><span class="line"></span><br><span class="line">        String str=<span class="string">&quot;A&quot;</span>;</span><br><span class="line">        map.get(str).exe();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>子类利用父类的模板化方法，不同的子类分别实现模板方法中的抽象方法，从而实例化出不同的子类对象<br />您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>一个原型类，通过克隆这个原型类来进行创建新对象<br />浅克隆：对于基本数据类型，直接复制数值，引用数据类型则复制一份地址<br />深克隆：完完全全的进行复制一份，复制品和原型类之间没有关系</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>使用代理对象来代替对真实对象的访问，在不修改原对象的前提下提供额外的操作，扩展对象的目标功能<br />静态代理：在编译时就进行代理模类的实现，成为字节码文件<br />动态代理：<br />JDK动态代理（只能代理实现了接口的类）InvocationHandler 接口和 Proxy 类是核心。<br />CGLIB动态代理方式（通过继承来代理类）MethodInterceptor 接口和 Enhancer 类是核心</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="常见集合有哪些"><a href="#常见集合有哪些" class="headerlink" title="常见集合有哪些"></a>常见集合有哪些</h3><ul><li>List：存储的元素有序，可重复</li><li>Set：存储的元素不无序，不可重复</li><li>Map：是另外的接口，是键值对映射结构的集合</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1714140809280-aeee1de8-fbdb-4a20-9bcc-6d705d18a189.png#averageHue=%23fcfaf6&clientId=ud49fd56c-bc74-4&from=paste&height=333&id=u0c8a6d9b&originHeight=499&originWidth=1310&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=399622&status=done&style=none&taskId=u9e66286c-2760-43c0-8c4b-2b25f27230c&title=&width=873.3333333333334" alt="image.png"></p><h3 id="线程安全的集合有哪些"><a href="#线程安全的集合有哪些" class="headerlink" title="线程安全的集合有哪些"></a>线程安全的集合有哪些</h3><ul><li>Vector：synchronized 关键字来实现线程安全</li><li>HashTable：synchronized 关键字来实现线程安全</li><li>ConcurrentHashMap：分版本，后面笔记介绍</li><li>CopyOnWriteArrayList：写操作时进行复制</li><li>ConcurrentLinkedQueue：不清楚，可以不说</li></ul><h3 id="ArrayList和LinkedList有什么区别"><a href="#ArrayList和LinkedList有什么区别" class="headerlink" title="ArrayList和LinkedList有什么区别"></a>ArrayList和LinkedList有什么区别</h3><ol><li>数据结构不同：ArrayList 基于数组，LinkedList基于链表</li><li>多数情况下，ArrayList更利于查找，LinkedList更利于增删</li><li>是否支持随机访问：ArrayList实现了RandomAccess接口，支持通过序号获取元素对象实现随机访问</li><li>内存占用：ArrayList会预留一部分内存给预定义长度，LinkedList的指针会消耗内存</li></ol><h3 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h3><p>ArrayList的扩容是创建⼀个<strong>1.5</strong>倍的新数组，然后把原数组的值拷贝过去。</p><h3 id="ArrayList的序列化"><a href="#ArrayList的序列化" class="headerlink" title="ArrayList的序列化"></a>ArrayList的序列化</h3><p>它使用 transient 修饰存储元素的数组，防止其被序列化<br />因为有些空间可能没用到，不进行序列化可以提高效率</p><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>线程安全版本的ArrayList，实现读写分离<br />允许并发读，无锁限制；写的时候，就复制一份内容，在副本上进行加锁修改，改完后修改原容器的引用</p><h3 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h3><p>1.7是数组+链表<br />1.8是数据+链表+红黑树<br />在链表长度大于8时，转换为红黑树，但是需要先判断数组长度是否小于64，小于的话就先扩容数组，大于就转换为红黑树</p><h3 id="红黑树-二叉树-平衡树"><a href="#红黑树-二叉树-平衡树" class="headerlink" title="红黑树 &amp; 二叉树 &amp; 平衡树"></a>红黑树 &amp; 二叉树 &amp; 平衡树</h3><p>红黑树本质是一种平衡的二叉查找树</p><ol><li>每个节点要么是红色，要么是黑色；</li><li>根节点永远是黑色的；</li><li>所有的叶子节点都是是黑色的（注意这⾥说叶⼦节点其实是图中的 NULL 节点）；</li><li>每个红色节点的两个子节点⼀定都是黑色；</li><li>从任⼀节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；</li></ol><p>不用二叉树：红黑树各种时间复杂度为logn，二叉树为n<br />不用平衡二叉树：平衡二叉树为了保持更严格的平衡，需要进行更多的旋转次数<br />通过旋转和节点染色来保持平衡</p><h3 id="HashMap的put方法"><a href="#HashMap的put方法" class="headerlink" title="HashMap的put方法"></a>HashMap的put方法</h3><ol><li>根据key值计算哈希值</li><li>判断map是否为空，为空就扩容（开始不分配空间？）</li><li>计算数组下标</li><li>下标位置为空？不为空判断key是否相同，为空添加元素</li><li>key相同则覆盖元素，否则判断是否树节点来判断是根据链表插入还是红黑树插入</li><li>插入的时候判断扩容条件是否满足</li></ol><h3 id="HashMap的查找"><a href="#HashMap的查找" class="headerlink" title="HashMap的查找"></a>HashMap的查找</h3><ol><li>计算哈希值，判断map是否为空</li><li>计算在数组中的位置，判断是否为查找节点</li><li>判断该位置连接的是链表还是红黑树，进行查找</li><li>返回结果</li></ol><h3 id="HashMap容量为什么是2的倍数"><a href="#HashMap容量为什么是2的倍数" class="headerlink" title="HashMap容量为什么是2的倍数"></a>HashMap容量为什么是2的倍数</h3><ol><li>方便哈希取余，位运算比求余%更快</li><li>扩容时，利用扩容后的⼤小也是2的倍数，将已经产生hash碰撞的元素完美的转移到新的table中去</li></ol><h3 id="解决哈希冲突的方法"><a href="#解决哈希冲突的方法" class="headerlink" title="解决哈希冲突的方法"></a>解决哈希冲突的方法</h3><ul><li>链地址法</li><li>线性（平方）探查法</li><li>再哈希法，换哈希函数计算</li><li>建立公共溢出区，把冲突元素放进去</li></ul><h3 id="jdk1-8做了那些优化"><a href="#jdk1-8做了那些优化" class="headerlink" title="jdk1.8做了那些优化"></a>jdk1.8做了那些优化</h3><ol><li>数据结构变为数组+链表+红黑树</li><li>链表改为尾插法</li><li>扩容时不需重新进行哈希定位计算</li><li>1.8在插入完成后才判断是否需要扩容</li><li>1.8只做一次异或操作</li></ol><h3 id="HashMap多线程下问题"><a href="#HashMap多线程下问题" class="headerlink" title="HashMap多线程下问题"></a>HashMap多线程下问题</h3><ol><li>扩容死循环，1.7使用头插法可能会出现循环链表</li><li>put造成元素丢失，如果计算出来的索引位置是相同的，那会造成前⼀个 key 被后⼀个 key 覆盖</li><li>put 和 get 并发时，可能导致 get 为 null</li></ol><h3 id="解决线程不安全问题"><a href="#解决线程不安全问题" class="headerlink" title="解决线程不安全问题"></a>解决线程不安全问题</h3><ul><li>HashTable 是直接在操作方法上加 synchronized 关键字，锁住整个table数组，粒度比较大</li><li>ConcurrentHashMap 在jdk1.7中使⽤分段锁，在jdk1.8中使⽤CAS+synchronized<ul><li>分段锁：一个ConcurrentHashMap分为不同的Segment，每个Segment都是一个HashMap，通过在不同的Segment上加锁实现线程安全</li><li>CAS + synchronized：数据结构和HashMap一致，通常使用CAS进行写操作，在某些关键操作（树化、扩容等）就加上synchronized关键字</li></ul></li></ul><h3 id="LinkedHashMap-TreeMap实现有序"><a href="#LinkedHashMap-TreeMap实现有序" class="headerlink" title="LinkedHashMap &amp; TreeMap实现有序"></a>LinkedHashMap &amp; TreeMap实现有序</h3><p>LinkedHashMap：在HashMap基础上，维护了一个双向链表<br />TreeMap：按照key来排序，维护了一个红黑树</p><h3 id="HashSet怎么保证key唯一"><a href="#HashSet怎么保证key唯一" class="headerlink" title="HashSet怎么保证key唯一"></a>HashSet怎么保证key唯一</h3><p>重写元素的hashCode和equals方法，在插入时会先判断哈希值是否相等，再由equals方法判断内容是否相同，相同则不进行插入</p><h3 id="ArrayBlockingQueue-和-LinkedBlockingQueue"><a href="#ArrayBlockingQueue-和-LinkedBlockingQueue" class="headerlink" title="ArrayBlockingQueue 和 LinkedBlockingQueue"></a><a href="https://javaguide.cn/java/collection/java-collection-questions-01.html#arrayblockingqueue-%E5%92%8C-linkedblockingqueue-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">ArrayBlockingQueue 和 LinkedBlockingQueue</a></h3><ul><li>底层数据结构不同</li><li>ArrayBlockingQueue是有界的，LinkedBlockingQueue默认是无界的，也可以设置有界</li><li>ArrayBlockingQueue的生产者消费者共用一把锁，LinkedBlockingQueue的锁是分离的</li><li>ArrayBlockingQueue预先分配空间，LinkedBlockingQueue随节点数增加而增加</li></ul><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><ul><li><strong>InputStream</strong>：read(), skip() 忽略n个字符, available() 可以读取的字节数, close()<ul><li>FileInputStream(读取文件)</li><li>ObjectInputStream(序列化)</li><li>DataInputStream(读取指定类型)</li></ul></li><li><strong>OutputStream</strong>：write(), flush() 刷新并写出缓冲中所有字节, close()<ul><li>FileOutputStream(输出文件文件)</li><li>ObjectOutputStream(反序列化)</li><li>DataOutputStream(写入指定类型数据)</li></ul></li></ul><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><ul><li><strong>Reader</strong>：read(), skip(), close()</li></ul><p>InputStreamReader是字节流转换为字符流的桥梁，其子类 FileReader 是基于该基础上的封装</p><ul><li><strong>Writer</strong>：write(), append(), flush(), close()</li></ul><p>OutputStreamWriter 是字符流转换为字节流的桥梁，其子类 FileWriter 是基于该基础上的封装</p><h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><p>字节缓冲流这里采用了装饰器模式来增强 InputStream 和OutputStream子类对象的功能</p><ul><li>BufferedInputStream：先将读取到的字节放入缓存中，再从缓存读取</li><li>BufferedOutputStream：先把字节写在缓存中，再一次性写入磁盘，减少IO</li></ul><h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><p>类似于字节缓冲流</p><ul><li>BufferedReader</li><li>BufferedWriter</li></ul><h3 id="IO设计模式"><a href="#IO设计模式" class="headerlink" title="IO设计模式"></a>IO设计模式</h3><ol><li>装饰器模式</li></ol><p> 可以在不改变原有对象的情况下拓展其功能<br />举个例子，我们可以通过 BufferedInputStream（字节缓冲输入流）来增强 FileInputStream 的功能</p><ol start="2"><li>适配器模式</li></ol><p>主要用于接口互不兼容的类的协调工作<br />InputStreamReader 和 OutputStreamWriter 就是两个适配器(Adapter)， 同时，它们两个也是字节流和字符流之间的桥梁，他们实现了字节流和字符流之间的转换</p><ol start="3"><li>工厂模式</li></ol><p>用于创建对象，例子不是很熟</p><ol start="4"><li>观察者模式</li></ol><p>NIO 中的文件目录监听服务使用到了观察者模式<br />也不是很熟，讲讲前两种就差不多了</p><h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><ol><li>BIO (Blocking I&#x2F;O)</li></ol><p>同步阻塞I&#x2F;O模型<br />发起I&#x2F;O请求后就阻塞自己等到I&#x2F;O完成再继续执行</p><ol start="2"><li>NIO (Non-blocking I&#x2F;O)</li></ol><p>属于是IO多路复用模型，同步非阻塞模型<br />client -&gt; buffer -&gt; channel -&gt; selector<br />selector不断轮询channel是否有准备好的读写事件，有就执行</p><ol start="3"><li>AIO (Asynchronous I&#x2F;O)</li></ol><p>异步非阻塞模型，基于事件和回调机制实现，当操作完成后会通知相应线程进行后续的操作<br />总结：同步异步主要是看结果执行完成后，是线程自己查看是否完成还是会回调线程通知线程已经完成；阻塞和非阻塞就是看线程会一直等任务执行完成还是先做自己的事，时不时询问有没有执行完成</p>]]></content>
      
      
      <categories>
          
          <category> 八股 </category>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八股 </tag>
            
            <tag> Java </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC</title>
      <link href="/xingliu-test/2024/04/10/JUC/"/>
      <url>/xingliu-test/2024/04/10/JUC/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁&amp;悲观锁"></a>乐观锁&amp;悲观锁</h3><p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。（多写场景）<br />乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）（多读场景）<br /><strong>版本号机制：</strong>每次要更新数据时，会读取一个版本号，在提交更新时，会判断版本号和自己获取的是否相同<br /><strong>CAS算法：</strong>比较与替换，CAS（V,E,N）V：表示要更新的变量E：表示预期值N：表示新值；每次更新时比较预期值是否和要更新的变量相等，相等则可以修改，否则说明被其他线程修改了<br />CAS问题：</p><ol><li>ABA问题：比较值相等并不一定就是没有修改过，可能修改为其他值又修改回来的。</li></ol><p>乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1 操作，否则就执行失败</p><ol start="2"><li>循环性能开销：⾃旋CAS，如果⼀直循环执⾏，⼀直不成功，会给CPU带来⾮常⼤的执⾏开销。</li></ol><p>设置自旋次数，超过次数就停止自旋</p><ol start="3"><li>只能保证一个变量的原子操作</li></ol><p>使用加锁或者将多个变量封装成一个对象来操作</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>线程本地变量。如果你创建了⼀个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的⼀个本地拷贝，多个线程操作这个变量的时候，实际是操作⾃⼰本地内存⾥⾯的变量，从⽽起到线程隔离的作⽤，避免了线程安全问题。<br />原理：</p><ul><li>Thread类有⼀个类型为ThreadLocal.ThreadLocalMap的实例变量threadLocals，每个线程都有⼀个属于自己的ThreadLocalMap。 </li><li>ThreadLocalMap内部维护着Entry数组，每个Entry代表⼀个完整的对象，key是ThreadLocal的弱引⽤，value是ThreadLocal的泛型值。 </li><li>每个线程在往ThreadLocal里设置值的时候，都是往自己的ThreadLocalMap⾥存，读也是以某个ThreadLocal作为引用，在自己的map⾥找对应的key，从而实现了线程隔离。 </li><li>ThreadLocal本身不存储值，它只是作为⼀个key来让线程往ThreadLocalMap里存取值。</li></ul><p>总结：Thread有一个ThreadLocalMap，里面存储了每个线程的Entry&lt;k,v&gt;，k为线程ThreadLocal的弱引用，v为存储的值，设置或者获取值时根据ThreadLocal来，从而实现线程的隔离<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1713332259014-253c3378-1ac2-4ecc-bd65-2beb78df6a92.png#averageHue=%23f5f1db&clientId=u799c394e-74a2-4&from=paste&height=291&id=u9ce8aa00&originHeight=436&originWidth=762&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=47771&status=done&style=none&taskId=u156eba00-4cd3-431e-8fad-d694dc73c30&title=&width=508" alt="image.png"><br />内存泄露<br />栈中存储了ThreadLocal、Thread的引用，堆中存储了它们的具体实例</p><blockquote><p>弱引⽤：只要垃圾回收机制一运⾏，不管JVM的内存空间是否充足，都会回收该对象占⽤的内<br>存</p></blockquote><p>ThreadLocalMap存的是ThreadLocal的弱引用，如果ThreadLocal被回收了，value还在，造成内存泄露问题（确保最后一定调用remove（）方法）<br />为什么设计为弱引用<br />如果是强引用，ThreadLocal引用销毁时，key还是强引用指向ThreadLocal，那么垃圾回收器就不能回收ThreadLocal，从而内存泄漏<br />ThreadLocalMap结构<br />并没有实现map接口，而是通过Entry类型的数组储存数据，利用哈希取余法将key映射到对应的数组下标<br />使用线性探测法解决hash冲突（这个位置不行看看下一个位置）<br />扩容机制：先清理过期的Entry，再判断是否扩容；遍历扩容到新数组，两倍扩容</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>定义：线程池是用于管理线程的资源池，它可以使一些线程保持存活状态；有新任务时直接用，而不是需要时创建线程，用完就销毁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">int</span> corePoolSize,//线程池的核心线程数量</span></span><br><span class="line"><span class="params">  <span class="type">int</span> maximumPoolSize,//线程池的最大线程数</span></span><br><span class="line"><span class="params">  <span class="type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span><br><span class="line"><span class="params">  TimeUnit unit,//时间单位</span></span><br><span class="line"><span class="params">  BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span></span><br><span class="line"><span class="params">  ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span></span><br><span class="line"><span class="params">  RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span><br><span class="line"><span class="params">                          )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>corePoolSize：核心线程数，任务队列未达最大时可以运行的最大线程数<br />maximumPoolSize：线程池可以同时运行的最大线程数<br />keepAliveTime：多余核心线程的空闲线程的存活时间<br />workQueue：任务队列<br />threadFactory：线程工厂<br />handler：当没有足够线程服务时，采取的拒绝策略<br />四种拒绝策略</p><ol><li>直接抛出异常拒绝服务</li><li>调用execute的调用者用自己的线程执行方法，要是线程关闭了就丢弃任务</li><li>直接丢弃</li><li>丢弃最早的没处理的任务</li></ol><p>创建线程池<br />1. 通过ThreadPoolExecutor构造函数来创建（推荐）<br />2. 通过 Executor 框架的工具类 Executors 来创建（提供了一些线程池模板，底层还是使用了ThreadPoolExecutor）<br />原理</p><ol><li>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</li><li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。（队列没满，还不忙，不需要帮手）</li><li>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。（队列都满了，需要外援，增加线程）</li><li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用RejectedExecutionHandler.rejectedExecution()方法。</li></ol><p>对比</p><ul><li>Runnable 接口不会返回结果或抛出检查异常，但是 Callable 接口可以</li><li>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get()方法来获取返回值</li><li>shutdown（）停止后要把剩下任务执行完毕；shutdownNow（）返回未被执行的任务列表</li><li>isShutDown 当调用 shutdown() 方法后返回为 true；isTerminated 当调用 shutdown() 方法后，并且所有提交的任务完成后返回为 true（判断关闭的标准不同，任务是否完全执行完毕）</li></ul><p>常见线程池</p><ul><li>new FixedThreadPool (固定数⽬线程的线程池) </li><li>new CachedThreadPool (可缓存线程的线程池) </li><li>new SingleThreadExecutor (单线程的线程池) </li><li>new ScheduledThreadPool (定时及周期执⾏的线程池)</li></ul><h3 id="操作系统知识"><a href="#操作系统知识" class="headerlink" title="操作系统知识"></a>操作系统知识</h3><p><strong>并行</strong>是同一时刻两个线程同时执行，并发是同一时段两个线程进行切换执行<br /><strong>进程</strong>是代码在数据集合上的一次运行活动，是操作系统分配资源的最小单位；<strong>线程</strong>是进程的一个执行路径，是CPU分配资源的最小路径<br /><strong>线程创建方式</strong>：继承Thread类，实现Runnable接口，实现Callable接口（有返回值，能抛异常）<br />调用<strong>start（）</strong>方法是新建线程调用，<strong>run（）</strong>方法是在主线程中调用<br />子线程调用<strong>join（）</strong>方法，父线程停止等待子线程执行完成<br /><strong>线程上下文切换</strong>：CPU分配时间片，挂起线程把资源给别的线程<br /><strong>守护线程</strong>是为<strong>用户线程</strong>服务的，比如垃圾回收线程，只有所有用户线程结束，回收线程才会自动结束生命周期<br /><strong>线程通信方式</strong>：Thread.join()，ThreadLocal，synchronized实现加锁等</p><h3 id="原子性、可见性、有序性"><a href="#原子性、可见性、有序性" class="headerlink" title="原子性、可见性、有序性"></a>原子性、可见性、有序性</h3><p>原子性：不可再分，要么成功要么失败（synchnized）<br />可见性：修改了某个共享变量后其他的线程是否能够感知（volatile）<br />有序性：单线程没有问题，并发时会发生指令重排（两个关键字都可以）</p><h3 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h3><p>使用该字段的变量在被修改时会被刷新会主内存（存放线程共享变量的地方），读取时也需要从主内存读取</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a><strong>synchronized</strong></h3><p>修饰代码块，修饰静态方法，修饰实例方法<br />基于<strong>Monitor</strong>机制实现<br />可见性：加锁前从主内存读取最新数据，加锁后不允许其他线程获取共享数据，解锁前把数据写入主内存<br />有序性：保证执行结果的有序性<br />可重入：在加锁时有一个state变量记录加锁次数，同样解锁也需要根据这个变量来判断</p><h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的 <br />情况下，这些线程会⼀直相互等待而无法继续运行下去。<br />互斥条件：资源只能被一个线程使用（无法破坏）<br />请求并持有：在申请其他资源的时被阻塞又不释放自己的资源（可以一次性请求所有资源）<br />不可剥夺：我不释放的资源，别人也别想用（申请其他资源不到就释放所有资源）<br />环路等待：申请资源时出现环（按照资源序号申请）</p><h3 id="CountDownLatch-CyclicBarrier"><a href="#CountDownLatch-CyclicBarrier" class="headerlink" title="CountDownLatch &amp; CyclicBarrier"></a><strong>CountDownLatch &amp; CyclicBarrier</strong></h3><p><strong>CountDownLatch：</strong>用来协调多个线程之间的同步，或者说起到线程之间的通信，比如多个线程同时结束才能通过，或者同步多个线程的执行起点<br /><strong>CyclicBarrier：</strong>它可以阻塞多个线程，直到某个事件的发生才能执行后续操作（栅栏）<br />闭锁用于等待事件，而栅栏用于等待其他线程</p><ul><li>CountDownLatch是⼀次性的，⽽CyclicBarrier则可以多次设置屏障，实现重复利⽤； </li><li>CountDownLatch中的各个⼦线程不可以等待其他线程，只能完成⾃⼰的任务；⽽CyclicBarrier 中的各个线程可以等待其他线程</li></ul><p>Semaphore（信号量）是⽤来控制同时访问特定资源的线程数量</p><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>它是一种抽象出来的模型，包括主内存和本地内存<br />主内存存放共享变量，本地内存存放该线程以读&#x2F;写共享变量的副本</p><h3 id="线程交替打印"><a href="#线程交替打印" class="headerlink" title="线程交替打印"></a>线程交替打印</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; <span class="number">100</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + count++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;偶数线程&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; <span class="number">100</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + count++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;奇数线程&quot;</span>).start();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 八股 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> 八股 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/xingliu-test/2024/03/21/Spring/"/>
      <url>/xingliu-test/2024/03/21/Spring/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a href="https://cyborg2077.github.io/2023/04/28/InQString/">Spring面试题</a></p><h2 id="Autowired和-Resource"><a href="#Autowired和-Resource" class="headerlink" title="@Autowired和@Resource"></a>@Autowired和@Resource</h2><p><strong>联系</strong></p><ul><li>@Autowired和@Resource注解都是作为bean对象注入的时候使用的</li><li>两者都可以声明在字段和setter方法上</li><li>注意：如果声明在字段上，那么就不需要再写setter方法。但是本质上，该对象还是作为set方法的实参，通过执行set方法注入，只是省略了setter方法罢了</li></ul><p><strong>区别</strong></p><ul><li>@Autowired注解是Spring提供的，而@Resource注解是J2EE本身提供的</li><li>@Autowird注解默认通过byType方式注入，而@Resource注解默认通过byName方式注入</li><li>@Autowired注解注入的对象需要在IOC容器中存在，否则需要加上属性required&#x3D;false，表示忽略当前要注入的bean，如果有直接注入，没有跳过，不会报错</li></ul><p>@Autowird默认的注入方式为byType，也就是根据类型匹配，当有多个实现时，则通过byName注入，也可以通过配合@Qualifier注解来显式指定name值，指明要使用哪个具体的实现类（先判断类型是否匹配，再根据name匹配）<br />@Resource默认通过byName注入，如果没有匹配则通过byType注入</p><h2 id="依赖注入的方式"><a href="#依赖注入的方式" class="headerlink" title="依赖注入的方式"></a>依赖注入的方式</h2><ol><li><p><strong>构造器注入</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使用构造器注入方式，将UserRepository类型的依赖项注入到UserService中</span><br><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">    private UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    public UserService(UserRepository userRepository) &#123;</span><br><span class="line">        this.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为构造器的参数，进行传递后复制给局部变量</p></li><li><p>可注入不可变对象；</p></li><li><p>注入对象不会被修改；</p></li><li><p>注入对象会被完全初始化；</p></li><li><p>通用性更好。</p></li><li><p><strong>setter方式注入</strong></p></li></ol><p>类似于构造器注入，不过换成了setter方法，对象创建后手动调用</p><ul><li>无法注入一个不可变的对象（final 修饰的对象）</li><li>注入对象可被修改</li></ul><ol start="3"><li><strong>属性注入</strong></li></ol><p>@Autowired注解使用的方式</p><ul><li>无法注入一个不可变的对象（final 修饰的对象）</li><li>只能适应于 IoC 容器；</li><li>更容易违背单一设计原则</li></ul><h2 id="Spring是什么"><a href="#Spring是什么" class="headerlink" title="Spring是什么"></a>Spring是什么</h2><p>Spring是一个轻量级的IoC和AOP容器框架。是为Java应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发。Spring的核心思想是通过依赖注入和面向切面编程来实现松耦合、可测试和易维护的应用程序<br />控制反转（IoC）, 依赖注入（DI），面向切面编程（AOP）</p><h2 id="SpringMVC的理解"><a href="#SpringMVC的理解" class="headerlink" title="SpringMVC的理解"></a>SpringMVC的理解</h2><p>SpringMVC是Spring框架的一个模块，它提供了一种基于MVC（Model-View-Controller）架构的web应用程序开发模型，实现了Web应用程序的分层架构和模块化开发<br />DispatcherServlet（前端控制器）接收用户发送过来的请求，由它决定转发给那个Handler（处理器），Handler选择合适的方法，通过model来处理业务逻辑，通过view来返回相应解结果</p><h2 id="SpringMVC常用注解"><a href="#SpringMVC常用注解" class="headerlink" title="SpringMVC常用注解"></a>SpringMVC常用注解</h2><p>@Controller，@RequestMapping，@RequestBody，@RequestParam，@PathVariable，@ResponseBody</p><h2 id="Spring的AOP理解"><a href="#Spring的AOP理解" class="headerlink" title="Spring的AOP理解"></a>Spring的AOP理解</h2><p><strong>定义：</strong>它可以在程序运行过程中动态的插入某些功能到代码中，实现更灵活的程序设计</p><ul><li>切点：首先我们要明确在哪些程序进行插入（指定插入范围）</li><li>通知：具体的插入行为，前置，后置，环绕，异常等</li><li>切面：定义切点和通知的代码，可以认为是一种类</li><li>连接点：所有可能出发AOP的连接点（具体的插入位置）</li><li>织入：把切面应用到目标对象并创建新的代理对象的过程</li></ul><p><strong>为什么使用：</strong>对于某些比较统一通用的功能（登录验证），在代码中加显得比较繁琐重复，并且和业务还没什么直接关系，不同位置写的代码一样，那么就可以考虑用AOP实现<br /><strong>Spring AOP 实现步骤</strong></p><ol><li><p>添加 Spring AOP 框架支持</p></li><li><p>定义切面和切点</p></li><li><p>实现通知</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-aop --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 当前类是一个切面</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserAspect</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个切点（设置拦截规则）</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.springaop.controller.UserController.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcut</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1713065396786-32cb9e69-7b60-456f-8e53-9aacfcf82389.png#averageHue=%233f3938&clientId=uf10fcab4-4e6e-4&from=paste&id=ue9f50842&originHeight=434&originWidth=1539&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u6519d5a7-e783-4fd1-aeca-fbfd3c11057&title="></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 当前类是一个切面</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserAspect</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个切点（设置拦截规则）</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.springaop.controller.UserController.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcut</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 pointcut 切点的前置通知</span></span><br><span class="line">    <span class="meta">@Before(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBefore</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行前置通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置通知</span></span><br><span class="line">    <span class="meta">@After(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行后置通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回之后通知</span></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行返回之后通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抛出异常之后通知</span></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterThrowing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行抛出异常之后通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加环绕通知</span></span><br><span class="line">    <span class="meta">@Around(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕通知：前置方法&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行拦截方法</span></span><br><span class="line">            result = joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕通知：后置方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>利用AOP统计每个方法的执行时间</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加环绕通知</span></span><br><span class="line"><span class="meta">@Around(&quot;pointcut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> &#123;</span><br><span class="line">    <span class="comment">// spring 中的时间统计对象</span></span><br><span class="line">    <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stopWatch.start(); <span class="comment">// 统计方法的执行时间，开始计时</span></span><br><span class="line">        <span class="comment">// 执行目标方法，以及目标方法所对应的相应通知</span></span><br><span class="line">        result = joinPoint.proceed();</span><br><span class="line">        stopWatch.stop(); <span class="comment">// 统计方法的执行时间，停止计时</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(joinPoint.getSignature().getDeclaringTypeName() + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">            joinPoint.getSignature().getName() +</span><br><span class="line">            <span class="string">&quot;执行花费的时间：&quot;</span> + stopWatch.getTotalTimeMillis() + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现原理</strong><br />Spring AOP 是构建在<strong>动态代理</strong>基础上，因此 <strong>Spring 对 AOP 的支持局限于方法级别的拦截</strong><br />Spring AOP 动态代理实现：<br />默认情况下，实现了接⼝的类，使⽤ AOP 会基于 JDK ⽣成代理类，没有实现接⼝的类，会基于 CGLIB ⽣成代理类</p></li><li><p>JDK Proxy（JDK 动态代理）</p></li><li><p>CGLIB Proxy：默认情况下 Spring AOP 都会采用 CGLIB 来实现动态代理，因为效率高</p></li></ol><p>CGLIB 实现原理：通过继承代理对象来实现动态代理的（子类拥有父类的所有功能）<br />CGLIB 缺点：不能代理最终类（也就是被 final 修饰的类）<br /><strong>JDK动态代理实现</strong><br />JDK动态代理依靠反射实现的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态代理：使⽤JDK提供的api（InvocationHandler、Proxy实现）</span></span><br><span class="line"><span class="comment">//此种⽅式实现，要求被代理类必须实现接⼝</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayServiceJDKInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//⽬标对象即就是被代理对象</span></span><br><span class="line"> <span class="keyword">private</span> Object target;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">PayServiceJDKInvocationHandler</span><span class="params">( Object target)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.target = target;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//proxy代理对象</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"> <span class="comment">//1.安全检查</span></span><br><span class="line"> System.out.println(<span class="string">&quot;安全检查&quot;</span>);</span><br><span class="line"> <span class="comment">//2.记录⽇志</span></span><br><span class="line"> System.out.println(<span class="string">&quot;记录⽇志&quot;</span>);</span><br><span class="line"> <span class="comment">//3.时间统计开始</span></span><br><span class="line"> System.out.println(<span class="string">&quot;记录开始时间&quot;</span>);</span><br><span class="line"> <span class="comment">//通过反射调⽤被代理类的⽅法</span></span><br><span class="line"> <span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line"> <span class="comment">//4.时间统计结束</span></span><br><span class="line"> System.out.println(<span class="string">&quot;记录结束时间&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> retVal;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> PayService target= <span class="keyword">new</span> <span class="title class_">AliPayService</span>();</span><br><span class="line"> <span class="comment">//⽅法调⽤处理器</span></span><br><span class="line"> <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PayServiceJDKInvocationHandler</span>(target);</span><br><span class="line"><span class="comment">//创建⼀个代理类：通过被代理类、被代理实现的接⼝、⽅法调⽤处理器来创建</span></span><br><span class="line"> <span class="type">PayService</span> <span class="variable">proxy</span> <span class="operator">=</span> (PayService) Proxy.newProxyInstance(</span><br><span class="line"> target.getClass().getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;PayService.class&#125;,handler);</span><br><span class="line"> proxy.pay();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CGLIB动态代理实现</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayServiceCGLIBInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"> <span class="comment">//被代理对象</span></span><br><span class="line"> <span class="keyword">private</span> Object target;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">PayServiceCGLIBInterceptor</span><span class="params">(Object target)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.target = target;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span><span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="comment">//1.安全检查</span></span><br><span class="line"> System.out.println(<span class="string">&quot;安全检查&quot;</span>);</span><br><span class="line"> <span class="comment">//2.记录⽇志</span></span><br><span class="line"> System.out.println(<span class="string">&quot;记录⽇志&quot;</span>);</span><br><span class="line"> <span class="comment">//3.时间统计开始</span></span><br><span class="line"> System.out.println(<span class="string">&quot;记录开始时间&quot;</span>);</span><br><span class="line">         <span class="comment">//通过cglib的代理⽅法调⽤</span></span><br><span class="line"> <span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> methodProxy.invoke(target, args);</span><br><span class="line"> <span class="comment">//4.时间统计结束</span></span><br><span class="line">System.out.println(<span class="string">&quot;记录结束时间&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> PayService target= <span class="keyword">new</span> <span class="title class_">AliPayService</span>();</span><br><span class="line"> PayService proxy= (PayService) Enhancer.create(target.getClass(),</span><br><span class="line">                   <span class="keyword">new</span> <span class="title class_">PayServiceCGLIBInterceptor</span>(target));</span><br><span class="line">         proxy.pay();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK 和 CGLIB 实现的区别<br />JDK 实现，要求被代理类必须实现接口，之后是通过 InvocationHander 及 Proxy，在运行时动态的在内存中生成了代理对象，该代理对象是通过实现同样的接口实现（类似静态代理接口实现的方式），只是该代理类是在运行期时，动态的织入统一的业务逻辑字节码来完成的<br />CGLIB 实现，被代理类可以不实现接口，是通过继承被代理类，在运行时动态的生成代理类对象，这种方式实现方式效率高<br /><a href="https://blog.csdn.net/m0_58761900/article/details/128999827">Spring AOP（AOP概念、组成、Spring AOP实现及实现原理）-CSDN博客</a></p><h2 id="Spring-AOP和AspectJ-AOP有什么区别"><a href="#Spring-AOP和AspectJ-AOP有什么区别" class="headerlink" title="Spring AOP和AspectJ AOP有什么区别"></a>Spring AOP和AspectJ AOP有什么区别</h2><ul><li>实现方式不同：SpringAOP是基于JDK动态代理和CGLIB的代理机制实现的，而AspectJ AOP则是基于字节码操纵实现的</li><li>织入的时机不同：Spring AOP在应用运行时织入，AspectJ AOP在编译时字节码织入</li><li>适用范围不同：Spring AOP适用于IoC容器，AspectJ AOP适合Java任何应用程序</li></ul><h2 id="Spring-AOP关注点和横切关注是什么"><a href="#Spring-AOP关注点和横切关注是什么" class="headerlink" title="Spring AOP关注点和横切关注是什么"></a>Spring AOP关注点和横切关注是什么</h2><ul><li>关注点是切点，用于指示在哪些位置需要执行额外的行为</li><li>横切关注是切面，包括切点和通知，用于将多个关注点的行为织入代码中</li></ul><h2 id="Spring的IoC怎么理解"><a href="#Spring的IoC怎么理解" class="headerlink" title="Spring的IoC怎么理解"></a>Spring的IoC怎么理解</h2><ul><li>Spring的IOC(Inversion of Control)是指将对对象的创建、组装、管理的责任交给容器，由容器负责对象之间的依赖关系。在IOC模式中，对象不再自己管理其他对象的依赖，而是将依赖关系反转给容器进行管理</li><li>在Spring中，IOC是通过依赖注入(Dependency Injection, DI)实现的，依赖注入是指容器通过自动或者手动的方式，将对象所依赖的其他对象或者资源注入到对象中，从而达到对象之间的松耦合。</li><li>通过使用IOC容器，可以实现对象之间的解耦，增加代码的灵活性和可维护性。同时IOC容器也提供了很多功能，例如对象的生命周期管理、AOP、事务管理等，可以大大减少开发者的工作量，提高开发效率</li><li>总的来说，Spring的IOC是通过依赖注入实现的，将对象之间的依赖关系交给容器进行管理，从而实现对象之间的松耦合和增强系统的可维护性和可扩展性</li></ul><h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p>Bean 是由 Spring IoC 容器实例化、组装和管理的对象。<br />Spring的Bean生命周期包括以下阶段</p><ol><li><p>实例化(Instantiation)：在这个阶段，Spring容器会先扫描所有的Bean定义，通过Bean定义中指定的构造函数或者工厂方法来创建Bean的实例</p></li><li><p>属性赋值(Populate Properties)：在这个阶段，Spring容器会将配置文件中指定的Bean属性或者引用注入到Bean实例中，通常是 @Autowired 注解的变量</p></li><li><p>初始化(Initalization)：在这个阶段，Spring容器会调用Bean的初始化方法(如果有)，并完成Bean的一些初始化操作，用户自定义的一些方法，比如initMethod、afterPropertiesSet方法 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestService</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bean填充属性后，会执行我&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在initMethod之前执行</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestotherService</span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>（initMethod =<span class="string">&quot;initMethod&quot;</span>)</span><br><span class="line">    <span class="keyword">public</span> TestService <span class="title function_">testService</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TestService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestService</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.out.println（<span class="string">&quot;afterPropertiesSet之后执行&quot;</span>）;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用(In Use)：在这个阶段，Bean可以被应用程序使用</p></li><li><p>销毁(Destruction)：在这个阶段，Spring容器会调用Bean的销毁方法(如果有)，并完成Bean的销毁操作</p></li></ol><p>这里会调用@PreDestroy注解标注的销毁前执行的方法，再进行真正的销毁，调用destory()方法完成销毁</p><h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><p>Spring支持一下五种Bean作用域</p><ul><li>Singleton(单例)：在整个应用程序中，只存在一个Bean实例。默认情况下，Spring中的Bean都是单例的</li><li>Prototype(原型)：每次通过容器获取Bean时，都会创建一个新的Bean实例</li><li>Request：在一次HTTP请求中，Bean的实例是唯一的</li><li>Session：在一个HTTP Session中，Bean的实例是唯一的</li><li>Global Session：在一个全局的HTTP Session中，Bean的实例是唯一的，后改为application</li></ul><p><a href="https://blog.csdn.net/lzb348110175/article/details/114387477">@Scope注解 详细讲解及示例-CSDN博客</a></p><h2 id="Bean是线程安全的吗"><a href="#Bean是线程安全的吗" class="headerlink" title="Bean是线程安全的吗"></a>Bean是线程安全的吗</h2><p>分情况讨论：<br />对于原型作用域：每次获取都生成一个新的对象，所以是线程安全的<br />对于单例作用域：默认是线程不安全的，但是开发中大部分的Bean都是无状态（没有属性对象）的，不需要保证线程安全。</p><ul><li>如果Bean不包含实例变量，或者所有的实例变量是线程安全的，那就线程安全</li><li>如果Bean包含实例变量，并且存在实例变量是线程不安全的，那就线程不安全</li></ul><p>实例变量就是类成员变量<br />要解决的话可以用ThreadLocal来解决，为每个线程保存一个副本变量，每个线程只操作自己的副本变量。</p><h2 id="Bean的储存"><a href="#Bean的储存" class="headerlink" title="Bean的储存"></a>Bean的储存</h2><p>bean对象最终存储在spring容器中，我们简单的、狭义上的spring容器，在spring源码底层就是一个map集合，这个map集合存储的key是当前bean的name，如果不指定，默认的是class类型首字母小写作为key，value是bean对象。存储bean的map在DefaultListableBeanFactory类中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Map of bean definition objects, keyed by bean name. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure><p>当Spring容器扫描到Bean类时 , 会把这个类的描述信息, 以包名加类名的方式存到beanDefinitionMap 中,<br />Map&lt;String,BeanDefinition&gt; , 其中 String是Key , 默认是类名首字母小写 , BeanDefinition , 存的是类的定义(描述信息) , 我们通常叫BeanDefinition接口为 : bean的定义对象。<br />Bean的定义信息和实例化好的Bean都是存储在不同的ConcurrentHashMap内，实例Bean时，会从BeanDefinition拿到Bean的定义信息，然后去实例化，最后放到对应的map中去。</p><h2 id="Spring循环依赖-三级缓存"><a href="#Spring循环依赖-三级缓存" class="headerlink" title="Spring循环依赖&amp;三级缓存"></a>Spring循环依赖&amp;三级缓存</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1713087703520-b1eb1fb9-4758-4289-89df-77e21fcbd2c8.png#averageHue=%23edeceb&clientId=u78b15685-ef67-4&from=ui&id=ud148f147&originHeight=885&originWidth=1438&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=149278&status=done&style=none&taskId=u89c32443-fa8d-4222-947d-b3f2a0c4363&title=" alt="p9Gnrd0.png"><br />整个流程大致如下：</p><ol><li>首先 A 完成初始化第一步并将自己提前曝光出来（通过 ObjectFactory 将自己提前曝光），在初始化的时候，发现自己依赖对象 B，此时就会去尝试 get(B)，这个时候发现 B 还没有被创建出来；</li><li>然后 B 就走创建流程，在 B 初始化的时候，同样发现自己依赖 C，C 也没有被创建出来；</li><li>这个时候 C 又开始初始化进程，但是在初始化的过程中发现自己依赖 A，于是尝试 get(A)。这个时候由于 A 已经添加至缓存中（一般都是添加至三级缓存 singletonFactories），通过ObjectFactory 提前曝光，所以可以通过 ObjectFactory.getObject() 方法来拿到 A 对象。C 拿到 A 对象后顺利完成初始化，然后将自己添加到一级缓存中；</li><li>回到 B，B 也可以拿到 C 对象，完成初始化，A 可以顺利拿到 B 完成初始化。到这里整个链路就已经完成了初始化过程了。</li></ol><p>Spring设置了三级缓存来解决循环依赖问题，</p><ul><li>一级缓存：里面存储完整的Bean实例，这些实例可以直接被使用；</li><li>二级缓存：储存实例化以后但是属性值还没有设置的Bean实例，也就是没有进行依赖注入；可以避免重复创建动态代理；</li><li>三级缓存用来存放Bean工厂，主要用来生成原始的Bean对象，并且放到第二个缓存里面</li></ul><p>三级缓存的核心思想就是把Bean的实例化和依赖注入进行分离，采用一级缓存储存完整的Bean实例，二级缓存储存不完整的Bean实例，通过不完整的Bean实例作为突破口，从而解决循环依赖问题</p><p>二级缓存能不能解决循环依赖</p><ol><li>一级缓存就可以解决循环依赖：无法解决在并发下获取不完整的Bean</li><li>二级缓存也可以，在创建了不完整的bean后放在二级缓存，如果Bean实现了AOP，那么在这个bean被重复依赖的时候，得到这个bean需要两次创建动态代理，因为你只有不完整的bean，如果有三级缓存，那么你就可以把创建动态代理的bean放入二级缓存，下次取不用再次创建动态代理。</li></ol><p>spring有没有解决多例bean的循环依赖</p><ul><li>不会使用缓存进行储存（每次使用都需要重新创建）</li><li>不缓存早期对象就无法解决循环依赖</li></ul><p>spring有没有解决构造函数的循环依赖</p><ul><li>没有解决</li><li>使用lazy来加载，延迟加载</li></ul><h2 id="用到的设计模式"><a href="#用到的设计模式" class="headerlink" title="用到的设计模式"></a>用到的设计模式</h2><ul><li>单例模式：Bean实例默认是单例的</li><li>原型模式：创建Bean时可以指定</li><li>工厂模式：将Ioc容器看作是一个工厂，通过工厂方法来创建Bean实例</li><li>模板模式：JdbcTemplate等模板类，将操作等封装好了</li><li>代理模式：aop就是使用代理实现的</li></ul><h2 id="Spring中ApplicationContext和BeanFactory"><a href="#Spring中ApplicationContext和BeanFactory" class="headerlink" title="Spring中ApplicationContext和BeanFactory"></a>Spring中ApplicationContext和BeanFactory</h2><ul><li>Spring中的ApplicationContext和BeanFactory都是IOC容器，负责管理和创建Bean实例，但他们之间有一些区别<ol><li>ApplicationContext是BeanFactory的子接口，它提供了更多的功能，例如国际化、事件驱动等</li><li>ApplicationContext会在启动时预先实例化所有的单例Bean，而BeanFactory则是按需创建Bean</li><li>ApplicationContext支持Bean的自动装配、AOP等功能，而BeanFactory需要手动配置</li><li>ApplicationContext支持多种资源加载方式，例如XML、注解、属性文件等，而BeanFactory只支持XML格式的配置文件</li><li>ApplicationContext提供了更多的扩展点，例如BeanPostProcessor、ApplicationListener等，可以对Bean的生命周期和时间进行监听和处理</li></ol></li><li>如果需要使用Spring的更高级特性，例如AOP、国际化、事件驱动等，可以选择使用ApplicationContext；如果只需要简单地创建和管理Bean实例，可以选择使用BeanFactory</li></ul><h2 id="事务的传播级别"><a href="#事务的传播级别" class="headerlink" title="事务的传播级别"></a>事务的传播级别</h2><p><strong>事务传播行为（propagation behavior）指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何运行</strong></p><ol><li>REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新事务，这是默认传播级别</li><li>SUPPORTS：支持当前事务，如果当前存在事务，则加入改事务；如果当前没有事务，则以非事务的方式继续执行</li><li>MANDATORY：强制要求存在事务，如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常</li><li>REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则挂起当前事务</li><li>NOT_WUPPORTED：以非事务方式执行操作，如果当前存在事务，则挂起当前事务</li><li>NEVER：以非事务方式执行操作，如果当前存在事务，则抛出异常</li><li>NESTEDD：如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则执行与REQUIRED传播级别类似的操作</li></ol><h2 id="Spring的事务实现方式"><a href="#Spring的事务实现方式" class="headerlink" title="Spring的事务实现方式"></a>Spring的事务实现方式</h2><ul><li>Spring中事务的实现方式主要有两种：编程式事务和声明式事务<ol><li>编程式事务：是指通过编写代码来控制事务的提交和回滚。在编程式事务中，开发人员需要手动获取事务管理器，并在需要的地方进行事务的开启、提交和回滚等操作。编程式事务虽然灵活，但是代码侵入性较高，容易造成代码臃肿和难以维护，因此Spring推荐使用声明式事务来实现事务管理</li><li>声明式事务：是指通过配置来控制事务的提交和回滚。在声明式事务中，开发人员只需使用注解或XML配置文件来声明事务的属性和行为即可，具体的事务管理操作则由Spring框架自动完成</li></ol></li><li>声明式事务的优点是代码简洁，易于维护，而且可以灵活切换事务管理方式。Spring中主要通过AOP技术实现声明式事务，其底层实现依赖于DataSourceTransactionManager和TransactionInterceptor等组件</li></ul><h2 id="事务注解的本质和优点"><a href="#事务注解的本质和优点" class="headerlink" title="事务注解的本质和优点"></a>事务注解的本质和优点</h2><p>事务注解的本质是通过Spring AOP机制，在方法执行前后动态创建代理对象，将方法包装在一个事务中。事务注解在执行方法前开启一个事务，如果方法执行成功，则提交事务；如果方法执行过程中发生异常，则回滚事务。通过事务注解，我们可以在方法上标记事务的属性，方便灵活地控制事务的执行行为。同时，由于Spring框架在底层处理事务，因此可以避免一些常见的事务处理问题，比如并发访问、死锁等问题。事务注解的使用简单，可以提高开发效率，降低代码复杂度。</p><ol><li>简化代码：使用Spring框架观念里事务可以大大简化代码量，使代码更易于维护</li><li>降低耦合性：使用Spring框架管理事务可以将业务逻辑与事务处理分离，降低了耦合性</li><li>避免重复代码：使用Spring框架管理事务可以避免在每个业务方法中重复编写事务管理代码</li><li>支持声明式事务：Spring框架支持声明式事务，可以通过注解或XML配置来定义事务的属性和行为</li><li>支持多种事务管理器：Spring框架支持多种事务管理器，包括JDBC事务、Hibernate事务、JPA事务、JTA事务等</li><li>支持事务的回滚和提交：Spring框架可以自动管理事务的提交和回滚，从而保证事务的一致性和完整性</li><li>提高事务的性能：Spring框架使用缓存和批处理等技术来提高事务的性能和效率</li></ol><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{}和${}的区别"></a>#{}和${}的区别</h2><p>前者是预编译，mybatis处理时将其替换为？，调用方法为其赋值<br />后者是字符替换，直接替换为变量的值<br />推荐使用#{}，防止SQL注入</p><h2 id="分页插件原理"><a href="#分页插件原理" class="headerlink" title="分页插件原理"></a>分页插件原理</h2><p>使用插件接口，在插件的拦截方法内拦截待执行的SQL并重写，添加分页语句和参数</p><h2 id="Mybatis缓存机制"><a href="#Mybatis缓存机制" class="headerlink" title="Mybatis缓存机制"></a>Mybatis缓存机制</h2><p>一级缓存：每个Sqlsession内部都持有了Executor，每个Executor中都有一个LocalCache，类似的现在LocalCache查，没有名字才去数据库查（很容易出现脏数据）<br />二级缓存：多个Sqlsession共享二级缓存，先查二级缓存再查一级缓存（分布式下必然出现脏数据，解决成本高，推荐使用Redis缓存）</p>]]></content>
      
      
      <categories>
          
          <category> 八股 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八股 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/xingliu-test/2024/03/20/JVM/"/>
      <url>/xingliu-test/2024/03/20/JVM/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM"></a>什么是JVM</h3><p>Java虚拟机，它是一个中间平台，对于任何可以编译为字节码文件的语言来说，都可以通过此平台翻译为不同平台的机器指令</p><h3 id="JVM的内存区域"><a href="#JVM的内存区域" class="headerlink" title="JVM的内存区域"></a>JVM的内存区域</h3><ul><li>程序计数器</li></ul><p>记录当前字节码的执行位置</p><ul><li>虚拟机栈</li></ul><p>存放方法执行时产生的栈帧，栈帧中用于存储局部变量表、操作数栈、动态链表、方法出口等信息</p><ul><li>本地方法栈</li></ul><p>虚拟机栈为虚拟机执行java方法服务，而本地方法栈为虚拟机执行Native方法服务</p><ul><li>堆</li></ul><p>存在的唯一目的就是存放对象实例，几乎所有的对象实例都在这里进行分配内存<br />是热点代码，能逃逸，开启标量替换<br />逃逸：对象被外部方法调用或者被外部线程访问<br />标量替换：如果⼀个数据是基本数据类型，不可拆分，它就被称之为标量。把⼀个 Java 对象拆散，将其⽤到的成员变量恢复为原始类型来访问，这个过程就称为标量替换<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1713237977893-73ccdcbf-44aa-4407-bc18-1f33c16324c9.png#averageHue=%23bbd6f5&clientId=u6c303ffd-2b97-4&from=paste&height=333&id=u4bc8df79&originHeight=500&originWidth=825&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=110230&status=done&style=none&taskId=ucf46b2b9-3568-46da-ad90-0c59d1bbf6e&title=&width=550" alt="image.png"></p><ul><li>方法区</li></ul><p>此区域是用来存储类的信息(类的名称、字段信息、方法信息)、静态变量、常量以及编译器编译后的代码<br />前三个线程私有，后两个线程共享</p><h3 id="可达性算法分析"><a href="#可达性算法分析" class="headerlink" title="可达性算法分析"></a>可达性算法分析</h3><p>垃圾回收时，由根节点进行链路分析来判断对象是否可达，如果不可达就是垃圾<br />另外一种算法：引用计数法，通过标记是否存在引用来判断是否垃圾，但是无法解决循环引用对象问题<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1713236406325-184a77b1-8a06-4eae-9b39-299decec024a.png#averageHue=%23a7dae7&clientId=u6c303ffd-2b97-4&from=paste&height=242&id=uec0c781e&originHeight=363&originWidth=773&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=139461&status=done&style=none&taskId=ufba4c2bf-6b5c-4f30-9b0c-bfec45e25f7&title=&width=515.3333333333334" alt="image.png"></p><h3 id="JVM中的垃圾收集算法"><a href="#JVM中的垃圾收集算法" class="headerlink" title="JVM中的垃圾收集算法"></a>JVM中的垃圾收集算法</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1713236522968-a7a00c4b-5fc2-4c59-b979-569363fad0d2.png#averageHue=%23aeb2b0&clientId=u6c303ffd-2b97-4&from=paste&height=328&id=uaf90a356&originHeight=604&originWidth=956&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=344179&status=done&style=none&taskId=ud850b7d3-725b-4735-8c32-dd2cfaffd38&title=&width=519.3333435058594" alt="image.png"></p><ol><li>复制算法：将内存分为两部分，对其中一部分进行垃圾回收时，将可用对象复制到另外一部分，空间利用率不高</li><li>标记清除算法：通过可达性分析去标记，再把垃圾对象进行清除，空间会变得碎片化</li><li>标记整理算法：同样可达性分析，在清除时把可用对象复制到一端，效率比较低</li></ol><h3 id="分代模型"><a href="#分代模型" class="headerlink" title="分代模型"></a>分代模型</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1713236894922-63e4adab-21ea-4b97-a66d-f842879a7a3c.png#averageHue=%23d9e7c0&clientId=u6c303ffd-2b97-4&from=paste&height=309&id=uc22806a4&originHeight=464&originWidth=839&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=91032&status=done&style=none&taskId=ud825b377-f8c1-43cb-881a-79ed86d8ac5&title=&width=559.3333333333334" alt="image.png"><br />新生代：消亡速度比较快，使用复制算法<br />老年代：多次回收都没有回收掉的对象，使用后两者算法都行<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1713238336438-6618e98f-d414-4962-ac97-d4bf8a5e50e1.png#averageHue=%23f2f1f2&clientId=u6c303ffd-2b97-4&from=paste&height=147&id=u7dc2f4eb&originHeight=220&originWidth=719&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=29014&status=done&style=none&taskId=uc1a368df-02c1-499a-b3e4-575f9d626d5&title=&width=479.3333333333333" alt="image.png"></p><h3 id="CMS垃圾回收器"><a href="#CMS垃圾回收器" class="headerlink" title="CMS垃圾回收器"></a>CMS垃圾回收器</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1713237053994-9d98a40c-db98-486c-b1d4-5d6794c07ed0.png#averageHue=%23f2f1f2&clientId=u6c303ffd-2b97-4&from=paste&height=360&id=ud4a08c56&originHeight=540&originWidth=701&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=117384&status=done&style=none&taskId=ud7e833bf-aa28-4ddc-9b48-bf2e78bb585&title=&width=467.3333333333333" alt="image.png"><br />两个大阶段：可达性分析、垃圾清理<br />可达性分析：</p><ol><li>停止线程STW，标记和根节点相连的对象</li><li>并发标记，线程业务和对象标记一起执行</li><li>停止线程STW，处理漏标问题</li></ol><p>垃圾清理：清理过程为并发清理<br /><strong>问题</strong>：</p><ul><li>并发清理意味着清理的同时会产生新的垃圾，这些垃圾只能在下一次清理</li><li>业务线程和回收线程同时跑，对CPU比较敏感</li><li>采用标记清除算法，空间碎片化</li></ul><h3 id="G1垃圾回收器"><a href="#G1垃圾回收器" class="headerlink" title="G1垃圾回收器"></a>G1垃圾回收器</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1713237579359-dc611c65-8afc-4ccf-8086-cbbb5444a902.png#averageHue=%23f3f2f3&clientId=u6c303ffd-2b97-4&from=paste&height=391&id=u5c2f8fa0&originHeight=587&originWidth=805&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=148583&status=done&style=none&taskId=uacb6cc71-a108-4c2b-904c-0f3b4b28092&title=&width=536.6666666666666" alt="image.png"><br />对内存进行区域划分，筛选出垃圾最多的区域进行清理，减少垃圾回收器的暂停时间<br />特点：</p><ul><li>空间整合，优先回收垃圾最多的区域</li><li>使用多线程（GC线程），回收线程和业务线程并发，可预测停顿（给定停顿时间，根据前面分区和线程并发尽可能的减少暂停时间）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1713250633953-4b593873-88f0-447a-a967-b9881f953ece.png#averageHue=%23f2f1f2&clientId=uac086589-dfec-4&from=paste&height=267&id=ub0dae7b7&originHeight=400&originWidth=1020&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=120259&status=done&style=none&taskId=u9c2e53e9-621f-426d-9510-a7d518b35ff&title=&width=680" alt="image.png"></p><h3 id="内存溢出和泄露"><a href="#内存溢出和泄露" class="headerlink" title="内存溢出和泄露"></a>内存溢出和泄露</h3><p><strong>内存溢出</strong>（OOM-OutOfMemory）是指JVM可用内存不足。<br />JVM运行需要使用的内存超出最大可用值，会导致JVM出现异常<br />常见的OOM有以下几种。</p><ul><li>栈溢出</li><li>堆溢出</li><li>方法区溢出</li><li>本机直接内存溢出</li></ul><p><strong>内存泄漏</strong>：不再使用的对象却继续占用内存，没有释放，这就叫内存泄漏</p><ul><li>静态集合类，其生命周期和JVM一致</li><li>单例模式，和静态集合类类似</li><li>连接未释放，数据库连接、IO连接等</li><li>ThreadLocal使用不当，未及时释放</li></ul><p><strong>与内存溢出的关系</strong><br />如果存在严重的内存泄漏问题，随着时间的推移，则必然会引起内存溢出。<br />内存泄漏一般是资源管理问题和程序BUG，内存溢出则是内存空间不足和内存泄漏的最终结果。</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>储存布局为：对象头、实例数据、对齐填充<br />对象头：第一部分存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等；第二部分指向它是那一个类所创建的，如果是数组则包括用于记录数组长度的数据<br />实例数据：主要是存放类的数据信息，父类的信息，对象字段属性信息<br />对齐填充：仅仅是占位符而已<br /><a href="https://www.cnblogs.com/jajian/p/13681781.html">Java对象的内存布局 - JaJian - 博客园</a></p><h3 id="Java8默认垃圾回收器"><a href="#Java8默认垃圾回收器" class="headerlink" title="Java8默认垃圾回收器"></a>Java8默认垃圾回收器</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1713239833891-47b2cba5-8365-4648-891a-fc0ff685dc61.png#averageHue=%2359d677&clientId=u6c303ffd-2b97-4&from=paste&height=326&id=u1b63bbab&originHeight=489&originWidth=1094&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=155269&status=done&style=none&taskId=u421707e9-bad6-4796-9c3a-c289f63bdd8&title=&width=729.3333333333334" alt="image.png"></p><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1713250171906-ef6f23ba-8928-46c1-8d60-525be01f2c1b.png#averageHue=%23fefdfd&clientId=uac086589-dfec-4&from=paste&height=256&id=ub4154b2f&originHeight=384&originWidth=649&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=64739&status=done&style=none&taskId=udc0bde1c-3897-4b8c-b760-e00b8b28d68&title=&width=432.6666666666667" alt="image.png"><br />Bootstrap：加载Java的核心类库<br />Extension：加载Java api的扩展<br />Application：加载程序员编写的一些代码以及一些第三方类库<br />Custom：用户自定义加载器<br />双亲委派机制可以被破坏，可以通过重写loadClass方法，根据全限定名来用Custom加载器来加载；或者连接数据库时，出现了Bootstrap 委托Application进行加载的情况。<br />除了顶层的类加载器，其他的加载器在加载某个类时，都会按照优先级向上询问是否已经加载了，没有的话会依次尝试进行加载。</p><ul><li>带有优先级的加载过程可以避免类的重复加载</li><li>可以保证一些核心api不会被随意替换（object），保证Java程序稳定运行</li></ul><p><a href="https://www.cnblogs.com/crazymakercircle/p/15554725.html">面试必备：什么时候要打破双亲委派机制？什么是双亲委派？ （图解+秒懂+史上最全） - 疯狂创客圈 - 博客园</a></p><h3 id="如何排查OOM"><a href="#如何排查OOM" class="headerlink" title="如何排查OOM"></a>如何排查OOM</h3><p>开启Heapdumponoutofmemory，得到堆转储文件，借助visualVM等工具打开这个日志文件，查找具体的错误信息</p><h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><ol><li>加载类的字节码文件将其转化为某种静态储存结构储存在方法区，并在堆中生成一个便于用户调用的java.lang.class类型的对象</li><li>验证class静态结构合法性</li><li>分配内存空间</li><li>解析，替换常量池中的符号引用为直接引用，类似于引用另外一个对象，这个引用就要从静态引用替换为直接引用（未使用多态解析发生在初始化之前，使用多态发生在初始化之后）</li><li>初始化静态代码块和静态变量</li></ol><p><a href="https://www.bilibili.com/video/BV14U4y1L75q/?spm_id_from=333.788&vd_source=76d07b2ac50fbbf69b312cadf6d1d849">【JVM】Java类加载机制这块算是玩明白了_哔哩哔哩_bilibili</a><br /><a href="https://blog.csdn.net/qq_48508278/article/details/122929631">类加载机制(整个过程详解)-CSDN博客</a></p><h3 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h3><ol><li>首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用对应的类是否已经被加载，解析和初始化过。如果没有，先要进行类加载过程。</li><li>为对象分配内存：</li></ol><ul><li>如果内存空间是规整的，则通过<strong>指针碰撞</strong>来为对象分配内存，未被使用和已被使用堆内存分开来放置在两侧，中间通过一个指针来作为分界的指示器，分配内存时只需将分界指针往未使用内存空间移动出对象所需空间即可。</li><li>如果内存空间是不规整的，则通过<strong>空闲列表</strong>来分配内存，虚拟机维护一个列表来记录哪些内存空间是未使用的，分配时在列表中找一个足够大的空间划分给该对象。</li></ul><ol start="3"><li>并初始化内存的变量值为零值</li><li>设置对象头，设置类型指针指向方法区的类型元数据，java虚拟机通过这个指针可以知道这个对象是哪个类的实例。设置mark word值，涵盖对象的hashcode，GC分代年龄和锁标识。</li><li>执行构造方法</li></ol><p><a href="https://zhuanlan.zhihu.com/p/240458901">安全验证 - 知乎</a></p><h3 id="JVM常见参数设置"><a href="#JVM常见参数设置" class="headerlink" title="JVM常见参数设置"></a>JVM常见参数设置</h3><p>堆的内存最小最大值<br />设置垃圾回收器<br />设置内存溢出时进行快照保存而不是报错</p><h3 id="new对象时，堆会发生抢占吗？怎么保证线程安全的"><a href="#new对象时，堆会发生抢占吗？怎么保证线程安全的" class="headerlink" title="new对象时，堆会发生抢占吗？怎么保证线程安全的"></a>new对象时，堆会发生抢占吗？怎么保证线程安全的</h3><p>会发生抢占，在分配内存时，指针会移动一个对象的size，给A分配内存时，指针还没修改，此时B分配内存又引用了这个指针，就发生抢占。</p><ul><li>采用CAS分配重试的方式来保证操作的原子性</li><li>为每个线程在堆中预先分配一小块内存，先用本地线程分配缓冲</li></ul><h3 id="对象引用方式"><a href="#对象引用方式" class="headerlink" title="对象引用方式"></a>对象引用方式</h3><ul><li>强引用：即使内存不够，也不会回收（常用的）</li><li>软引用：只在内存不够时才回收</li><li>弱引用：触发GC时，就回收</li><li>虚引用：基本等于没有，连根据引用获取对象都做不到，用于垃圾回收时的通知</li></ul><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><p>可达性分析后，如果某个对象不可达，就会被标记，第二次判断是否要回收时就是根据此方法来确定</p><h3 id="新生代-老年代"><a href="#新生代-老年代" class="headerlink" title="新生代&amp;老年代"></a>新生代&amp;老年代</h3><p>主要划分为新生代和老年代<br />新生代又划分为Eden和两块Survivor，平时会留一块Survivor空闲，当触发GC时，把存活的对象复制到空闲区，比例为8:1:1</p><ul><li>长期存活的对象进入老年代（15）</li><li>大对象直接进入老年代</li><li>新生代垃圾收集后仍有大量对象存活，把无法容纳的对象直接送入老年代</li></ul><h3 id="垃圾收集方式"><a href="#垃圾收集方式" class="headerlink" title="垃圾收集方式"></a>垃圾收集方式</h3><ul><li>Minor&#x2F;Young GC：新生代的垃圾收集（Eden区没有空间时触发）</li><li>Major&#x2F;Old GC：老年代的垃圾收集，只有CMS</li><li>Mixed GC：收集整个新生代和部分老年代的垃圾，只有G1</li><li>Full GC：收集整个堆和方法区的垃圾<ul><li>新生代收集之前老年代内存不足</li><li>新生代收集之后老年代内存空间不足</li><li>老年代内存空间不足</li><li>System.gc()命令触发</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 八股 </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八股 </tag>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/xingliu-test/2024/03/20/MySql/"/>
      <url>/xingliu-test/2024/03/20/MySql/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="1-索引是什么"><a href="#1-索引是什么" class="headerlink" title="1.索引是什么"></a>1.索引是什么</h3><p>索引是数据库中的一种数据结构，包含了对数据表所有记录的引用，可以帮助我们快速查找、更新数据，类似于书里面的目录。<br />优点：</p><ul><li>可以大大提高检索效率</li><li>提高系统的性能</li><li>通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p>缺点：</p><ul><li>创建和维护索引需要花费时间</li><li>索引需要真实物理空间来储存</li><li>数据进行修改时，索引也要进行改变</li></ul><h3 id="2-索引的分类"><a href="#2-索引的分类" class="headerlink" title="2.索引的分类"></a>2.索引的分类</h3><ul><li><p>普通索引：是MySQL中的基本索引类型，允许在定义索引的列中插入重复值和空值</p></li><li><p>唯一索引：要求索引列的值必须唯一，但允许有空值。</p></li><li><p>组合索引：则列值的组合必须唯一</p></li><li><p>主键索引：是一种特殊的唯一索引，在唯一索引上增加不为空约束，不允许有空值</p></li><li><p>全文索引：全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值</p></li><li><p>空间索引：创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MyISAM的表中创建</p></li></ul><h3 id="3-索引的底层实现"><a href="#3-索引的底层实现" class="headerlink" title="3.索引的底层实现"></a>3.索引的底层实现</h3><ul><li>Hash索引：为索引列计算哈希码，将哈希码存储在索引中，以及指向每个数据的指针<ul><li>等值查询速度很快，但是不支持范围查找</li><li>大量键重复时效率会很低，哈希碰撞</li></ul></li><li>二叉查找树：可以解决范围查找问题，但是极端情况会退化成链表，无法自己调整</li><li>红黑树：如果插入的数据是顺序插入时，树的高度随着数据量增加而增加</li><li>AVL树：可以范围查找，高度可以调整，但是调整成本比较高，而且一个节点存一个数据，会增加磁盘的IO</li><li>B-Tree索引：一个节点可以存多个数据<ul><li>树的高度相对于B+树更高一些</li><li>节点存的是数据，所能存的数据就更少一些 </li><li>IO次数高（通常高度更高）</li></ul></li><li>B+Tree索引：在B-Tree索引改进，数据都在叶子结点，叶子结点依据关键字大小进行顺序连接<ul><li>B+树存储的是索引（地址）</li><li>B+树的叶子节点是数据阶段用了一个链表串联起来，便于范围查找</li><li>一个节点存着大量索引，降低树的高度，减少I&#x2F;O</li><li>一颗B+树能存两千万行数据</li></ul></li></ul><p><a href="https://zhuanlan.zhihu.com/p/113917726">深入理解 Mysql 索引底层原理</a></p><h3 id="4-聚簇索引和非聚簇索引"><a href="#4-聚簇索引和非聚簇索引" class="headerlink" title="4.聚簇索引和非聚簇索引"></a>4.聚簇索引和非聚簇索引</h3><p>主键索引叶子节点的值存储的就是MySQL的数据行，普通索引的叶子节点的值存储的是主键值，这是了解聚簇索引和非聚簇索引的前提</p><h6 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h6><p>找到了索引就找到了需要的数据，那么这个索引就是聚簇索引，所以主键就是聚簇索引，修改聚簇索引其实就是修改主键</p><h6 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h6><p>索引的存储和数据的存储是分离的，也就是说找到了索引但没找到数据，需要根据索引上的值(主键)再次回表查询,非聚簇索引也叫做辅助索引</p><h6 id="非聚簇索引不一定会回表查询"><a href="#非聚簇索引不一定会回表查询" class="headerlink" title="非聚簇索引不一定会回表查询"></a>非聚簇索引不一定会回表查询</h6><p>如果查询语句的所有的查询字段都命中了索引，就不用进行回表查询了。<br /><a href="https://zhuanlan.zhihu.com/p/142139541">给我一分钟，让你彻底明白MySQL聚簇索引和非聚簇索引</a></p><h3 id="5-怎么判断要不要加索引"><a href="#5-怎么判断要不要加索引" class="headerlink" title="5.怎么判断要不要加索引"></a>5.怎么判断要不要加索引</h3><ol><li>根据数据特性，如果是唯一的，可以加唯一索引</li><li>对频繁排序和分组的列进行索引，多列就组合索引</li><li>数据量小的表不用索引</li><li>索引的列应该尽量的少</li><li>值的范围较少的列上不要添加</li><li>经常更新的表少加索引</li></ol><h3 id="6-创建了索引，一定走索引吗"><a href="#6-创建了索引，一定走索引吗" class="headerlink" title="6.创建了索引，一定走索引吗"></a>6.创建了索引，一定走索引吗</h3><p>不一定，在组合索引中，如果查询字段不符合该索引的最左前缀原则，则不会使用该索引</p><h3 id="7-如何判断索引是否生效，越多越好？"><a href="#7-如何判断索引是否生效，越多越好？" class="headerlink" title="7.如何判断索引是否生效，越多越好？"></a>7.如何判断索引是否生效，越多越好？</h3><p>可以使用EXPLAIN语句查看索引是否正在使用<br />不是越多越好，如果表进行经常性的更新操作，同时的也会更新索引，性能降低。</p><h3 id="8-联合索引"><a href="#8-联合索引" class="headerlink" title="8.联合索引"></a>8.联合索引</h3><p>使用多个字段建立的索引<br />为什么要注意顺序：因为索引是有序的，这个顺序依次按照建立索引的字段顺序进行排序，查询也要按照这个顺序来进行。</p><h3 id="9-最左前缀原则"><a href="#9-最左前缀原则" class="headerlink" title="9.最左前缀原则"></a>9.最左前缀原则</h3><p>最左优先，建立索引时把最常用的一列放最左边<br />mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a &#x3D;1 and b&#x3D;2 andc &gt;3 and d&#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整<br />&#x3D;和in可以乱序，比如a &#x3D; 1 and b &#x3D; 2 and c&#x3D; 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</p><h3 id="10-索引下推"><a href="#10-索引下推" class="headerlink" title="10.索引下推"></a>10.索引下推</h3><p><strong>关键词：“索引优化”</strong><br />减少回表次数，InnoDB只适用于二级索引<br />没有索引下推时，查到了数据会查询整条数据返回给MySQL服务器来判断是否满足条件；有索引下推后，会使用索引中的列来判断是否满足部分条件，满足才会回表查询，否则过滤。<br /><a href="https://juejin.cn/post/7005794550862053412">五分钟搞懂MySQL索引下推 - 掘金</a><br />在 people_table中有一个二级索引(zipcode，lastname，address)，查询是SELECT*FROM peopleWHERE zipcode&#x3D;’95054’ AND lastname LIKE “%etrunia%’ AND address LIKE “%Main Street%”</p><ul><li>如果没有使用索引下推技术，则MySQL会通过zipcode&#x3D;’95054’从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastnameLIKE‘%etrunia%’and address LIKE”%MainStreet%’来判断数据是否符合条件</li><li>如果使用了索引下推技术，则MYSQL首先会返回符合zipcode&#x3D;’95054’的索引，然后根据lastnameLIKE”%etrunia%’andaddressLIKE”%MainStreet%’来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。</li></ul><h3 id="11-创建索引的方式"><a href="#11-创建索引的方式" class="headerlink" title="11.创建索引的方式"></a>11.创建索引的方式</h3><ol><li>创建表时进行创建</li><li>ALTER TABLE进行增加索引</li><li>CREATE INDEX创建索引</li></ol><h3 id="12-使用索引一定能提高查询的性能吗"><a href="#12-使用索引一定能提高查询的性能吗" class="headerlink" title="12.使用索引一定能提高查询的性能吗"></a>12.使用索引一定能提高查询的性能吗</h3><p>不一定，在进行更新操作时，相应的索引也要进行IO处理，这样反而会变慢<br />使用情况：</p><ul><li>基于一个范围的检索，查询结果集小于表中记录数据的30%</li><li>基于非唯一性索引的检索</li></ul><h3 id="13-不走索引"><a href="#13-不走索引" class="headerlink" title="13.不走索引"></a>13.不走索引</h3><ul><li>使用!&#x3D;或者&lt;&gt;</li><li>模糊查询放在匹配字段前</li><li>NOT IN、NOT EXISTS</li><li>OR连接的不是同一个字段</li><li>对条件进行加减乘除的操作</li><li>使用了函数</li></ul><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>将SQL代码拼接到服务器执行的SQL语句中，造成危险后果。</p><ul><li>对参数进行严格的检验</li><li>SQL的预编译，将参数填充到占位符上</li></ul><h3 id="如何将一张表的部分数据更新到另一张表？"><a href="#如何将一张表的部分数据更新到另一张表？" class="headerlink" title="如何将一张表的部分数据更新到另一张表？"></a>如何将一张表的部分数据更新到另一张表？</h3><p>可以采用关联更新的方式，将一张表的部分数据，更新到另一张表内。参考如下代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update b set b.col=a.col from a,b where a.id=b.id;</span><br><span class="line">update b set col=a.col from b inner join a on a.id=b.id;</span><br><span class="line">update b set b.col=a.col from b left Join a on b.id = a.id;</span><br></pre></td></tr></table></figure><h3 id="WHERE和HAVING有什么区别？"><a href="#WHERE和HAVING有什么区别？" class="headerlink" title="WHERE和HAVING有什么区别？"></a>WHERE和HAVING有什么区别？</h3><p>WHERE是一个约束声明，使用WHERE约束来自数据库的数据，WHERE是在结果返回之前起作用的，WHERE中不能使用聚合函数。<br />HAVING是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作，在HAVING中可以使用聚合函数。另一方面，HAVING子句中不能使用除了分组字段和聚合函数之外的其他字段。<br />从性能的角度来说，HAVING子句中如果使用了分组字段作为过滤条件，应该替换成WHERE子句。因为WHERE可以在执行分组操作和计算聚合函数之前过滤掉不需要的数据，性能会更好。</p><h3 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h3><ol><li>列不可再分</li><li>行可以唯一区分，主键约束</li><li>非主属性不能依赖于其他表的非主属性，外键约束</li></ol><h3 id="InnoDB和MyISAM的区别"><a href="#InnoDB和MyISAM的区别" class="headerlink" title="InnoDB和MyISAM的区别"></a>InnoDB和MyISAM的区别</h3><ul><li>InnoDB支持事务…</li><li>InnoDB支持行级锁和表级锁…</li><li>InnoDB不支持全文搜索</li><li>InnoDB不保存表的行数</li><li>InnoDB支持外键</li></ul><h3 id="什么是存储过程"><a href="#什么是存储过程" class="headerlink" title="什么是存储过程"></a>什么是存储过程</h3><p>存储过程是一些预编译的SQL语句，类似于一个写好的方法</p><ul><li>实现效率高，在一定程度上保证数据安全</li><li>调试麻烦</li><li>代码可移植性低</li></ul><h3 id="mysql执行查询的过程"><a href="#mysql执行查询的过程" class="headerlink" title="mysql执行查询的过程"></a>mysql执行查询的过程</h3><ol><li>进行权限验证</li><li>查缓存</li><li>SQL语句分析</li><li>优化，是否使用索引</li><li>执行器执行语句</li></ol><p> 更新语句执行会复杂一点。需要检查表是否有排它锁，写 binlog，刷盘，是否执行 commit。</p><h3 id="in和exists关键字"><a href="#in和exists关键字" class="headerlink" title="in和exists关键字"></a>in和exists关键字</h3><blockquote><p><a href="https://so.csdn.net/so/search?q=%E5%AD%90%E6%9F%A5%E8%AF%A2&spm=1001.2101.3001.7020">子查询</a>表小的用in，子查询表大的用exists。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select * from t1 where <span class="title function_">exists</span> <span class="params">(select <span class="number">1</span> from t2 where t1.id = t2.id)</span>;</span><br><span class="line">select * from t1 where id <span class="title function_">in</span> <span class="params">(select id from t2)</span>;</span><br></pre></td></tr></table></figure><p>exists子句会对外表（即t1）用loop逐条记录查询，每次查询都会查看exists中的select语句，如果select子句返回记录行（无论返回记录行是多少，只要能返回），exists就会返回true，则外表中的当前记录就会被检索出来；如果select子句没有返回记录行，exists就会返回false，则外表中的当前记录就会被丢弃。——exist子句循环每次取出外表中的一条记录用来执行exists中的语句查内表，是先查外表，再查内表（相关子查询）。<br />in查询相当于多个or条件的叠加。in子句需要先将子查询的记录全部查出来。注意in子句中的子查询返回的结果集必须只有一个字段。假设子查询返回的结果集有m条记录，在进行m次查询。——in子句是先执行in中的子句查出来内表的结果，然后外表针对内表查出来的结果一个个遍历匹配。即先查内表，再查外表（不相关子查询）。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="1-事务和其特性"><a href="#1-事务和其特性" class="headerlink" title="1.事务和其特性"></a>1.事务和其特性</h3><p>事务就是多条SQL语句，这些操作要么都成功，要么都失败。</p><ul><li>原子性：整个事务是原子的，即成功失败都是一体的<ul><li>利用undo log实现事务的回滚</li></ul></li><li>一致性：不管事务执行成功与否，保证数据的一致性<ul><li>保证其它三个特性的完成</li></ul></li><li>隔离性：事务在执行时不受其它事务的干扰<ul><li>(一个事务)写操作对(另一个事务)写操作的影响：锁机制保证隔离性。</li><li>(一个事务)写操作对(另一个事务)读操作的影响：MVCC保证隔离性。</li></ul></li><li>持久性：事务的操作结果可以持久化到数据库中<ul><li>利用Buffer Pool来进行和读取，结合redo log实现持久化</li></ul></li></ul><h3 id="2-谈谈MySQL的事务隔离级别"><a href="#2-谈谈MySQL的事务隔离级别" class="headerlink" title="2.谈谈MySQL的事务隔离级别"></a>2.谈谈MySQL的事务隔离级别</h3><ul><li><p>读未提交（READ UNCOMMITTED）</p><pre><code>  所有事务都可以看到其他未提交事务的执行结果，脏读</code></pre></li><li><p>读提交 （READ COMMITTED）</p></li></ul><p>一个事务只能看到已经提交了的事务的改变，不可重复读</p><ul><li>可重复读 （REPEATABLE READ）</li></ul><p>一个事务执行过程中看到的数据和事务启动时看到的数据是一致的</p><ul><li>串行化 （SERIALIZABLE）</li></ul><p>强制事务排序，不可能冲突，导致大量的超时现象和锁竞争</p><ol><li>脏读：当前事务(A)中可以读到其他事务(B)未提交的数据（脏数据），这种现象是脏读。</li><li>不可重复读：在事务A中先后两次读取同一个数据，两次读取的结果不一样，这种现象称为不可重复读。脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据。</li><li>幻读：在事务A中按照某个条件先后两次查询数据库，两次查询结果的条数不同，这种现象称为幻读。不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了。</li></ol><p>脏读是一个事务的回滚影响另外一个事务；不可重复读则是侧重于数据的修改，两次读取数据不一致；幻读则是数据的行数发生了增加或者减少。</p><h3 id="3-MySQL隔离级别的实现机制"><a href="#3-MySQL隔离级别的实现机制" class="headerlink" title="3.MySQL隔离级别的实现机制"></a>3.MySQL隔离级别的实现机制</h3><ol><li>READ UNCOMMITTED</li></ol><p>读不加锁原理，写的时候加锁但是不妨碍读</p><ol start="2"><li>READ COMMITTED：</li></ol><p>通过Record Lock算法实现了行锁，但READ UNCOMMITTED允许读取未提交数据，所以存在脏读问题。而READ COMMITTED允许读取提交数据，所以不存在脏读问题，但存在不可重复读问题。</p><ol start="3"><li>REPEATABLE READ：</li></ol><p>快照读读的是这个事务开启时数据的一个快照版本；当前读读的是最新的一个数据，所以需要进行加锁处理<br />利用ReadView和MVCC，第一次读取数据时生成一个ReadView<br />使用Next-Key Lock算法实现了记录锁和间隙锁，并且不允许读取已提交的数据，所以解决了不可重复读的问题。另外，该算法包含了间隙锁，会锁定一个范围，因此也解决了幻读的问题。<br />幻读问题：部分解决，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id &#x3D; 5 的记录并提交。接着，事务 A 对 id &#x3D; 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A  再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读<br />要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。<br /><a href="https://blog.csdn.net/m0_71777195/article/details/126968432">美团三面：一直追问我， MySQL 幻读被彻底解决了吗？_mysql如何解决幻读-CSDN博客</a></p><ol start="4"><li>SERIALIZABLE：</li></ol><p>即为每个读取操作加一个共享锁。因此在这个事务隔离级别下，读占用了锁，对一致性的非锁定读不再予以支持。</p><h3 id="4-如何实现可重复读和解决幻读问题"><a href="#4-如何实现可重复读和解决幻读问题" class="headerlink" title="4.如何实现可重复读和解决幻读问题"></a>4.如何实现可重复读和解决幻读问题</h3><p>MySQL的InnoDB引擎，在默认的REPEATABLE READ的隔离级别下，实现了可重复读，同时也解决了幻读问题。它使用Next-Key Lock算法实现了行锁，并且不允许读取已提交的数据，所以解决了不可重复读的问题。另外，该算法包含了间隙锁，会锁定一个范围，因此也解决了幻读的问题。</p><h3 id="5-MVCC"><a href="#5-MVCC" class="headerlink" title="5.MVCC"></a>5.MVCC</h3><p>多版本并发控制，通过维护数据历史版本来解决并发访问情况下读一致性问题<br />InnoDB每一行数据都有两个隐藏的指针，分别指向当前修改的事务ID，上一个历史版本，每次更新时都会修改指针，从而形成了一个历史版本的版本链<br />ReadView：</p><ul><li>当前活跃的事务ID</li><li>当前活跃事务的最小ID</li><li>分配给下一个事务的ID</li><li>生成ReadView的事务ID</li></ul><p>判断流程：</p><ul><li>被访问数据的事务ID等于生成ReadView的事务ID，可以访问</li><li>被访问数据的事务ID小于最小事务ID，已经提交可以访问</li><li>被访问数据的事务ID大于下一个事务ID，不能访问</li><li>在两者范围之间，判断是否在活跃的事务ID内，在的话不能访问</li></ul><p>如果不能访问的话，那就根据版本链去查询历史版本<br />READ COMMITTED每次读取数据都创建ReadView，REPEATABLE READ第一次读取数据时生成一个ReadView</p><h3 id="6-MySQL的日志文件"><a href="#6-MySQL的日志文件" class="headerlink" title="6.MySQL的日志文件"></a>6.MySQL的日志文件</h3><ol><li>redo log：记录了InnoDB储存引擎的事务操作 （系统崩溃恢复）</li><li>undo log：事务开始之后，把事务的所有更新操作记录下来，用于事务的回滚（也叫事务日志）</li><li>binlog：记录所有数据库所有更改操作，用于数据备份，恢复的二进制日志</li><li>慢查询日志：记录查询时间长的查询语句</li><li>一般查询日志：记录了对数据库所有的请求</li><li>错误日志：对MySQL的运行错误进行了记录</li></ol><p>binlog &amp; redo log：</p><ul><li>binlog记录所有与数据库相关的日志记录，redo log只记录InnoDB储存引擎的日志</li><li>binlog用于数据备份恢复，redo log用于事务的持久和崩溃恢复</li><li>binlog在事务提交时写入，redo log事务执行过程中不断写入</li></ul><h3 id="7-MySQL两阶段提交事务"><a href="#7-MySQL两阶段提交事务" class="headerlink" title="7.MySQL两阶段提交事务"></a>7.MySQL两阶段提交事务</h3><p>redo log分两次写入<br />不管是先写binlog还是redo log，都会造成数据的不一致；在主从架构中主节点使用redo log恢复数据，从节点使用binlog恢复数据<br /><a href="https://zhuanlan.zhihu.com/p/343449447">安全验证 - 知乎</a></p><h3 id="1-数据库中的锁"><a href="#1-数据库中的锁" class="headerlink" title="1.数据库中的锁"></a>1.数据库中的锁</h3><p>锁是数据库系统区别于文件系统的一个关键特性，锁机制用于管理对共享资源的并发访问<br />下面我们以MySQL数据库的InnoDB引擎为例，来说明锁的一些特点。</p><h6 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h6><p>InnoDB存储引擎实现了如下两种标准的行级锁：</p><ul><li>共享锁（S Lock），允许事务读一行数据。</li><li>排他锁（X Lock），允许事务删除或更新一行数据。</li></ul><p>X和任何锁都不兼容，S只和S锁兼容</p><h6 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h6><p>InnoDB存储引擎支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式，称之为意向锁。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。</p><ul><li>意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁。</li><li>意向排他锁（IX Lock），事务想要获得一张表中某几行的排他锁。</li></ul><h6 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h6><p>InnoDB存储引擎有3种行锁的算法，其分别是：</p><ul><li>Record Lock：单个行记录上的锁。</li><li>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。</li><li>Next-Key Lock∶Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身。</li></ul><h6 id="关于死锁"><a href="#关于死锁" class="headerlink" title="关于死锁"></a>关于死锁</h6><p>死锁是两个或以上的事务，为争夺锁资源而互相等待的现象，通常没有外力无法推进下去<br />最简单的就是超时方法，等其中每一个事务超时后，进行了回滚，那么其他事务就能获得锁<br />wait-for graph（等待图）进行主动的检测是否有死锁</p><h3 id="2-介绍下间隙锁"><a href="#2-介绍下间隙锁" class="headerlink" title="2.介绍下间隙锁"></a>2.介绍下间隙锁</h3><p>间隙锁是数据库实现的三种行锁算法之一，它用于对某个范围进行加锁，防止多个事务对同一个范围内的数据进行修改，导致幻读的发生。</p><h3 id="3-InnoDB中行级锁是怎么实现的？"><a href="#3-InnoDB中行级锁是怎么实现的？" class="headerlink" title="3.InnoDB中行级锁是怎么实现的？"></a>3.InnoDB中行级锁是怎么实现的？</h3><p>对索引添加锁来实现，只有使用索引查找，才能使用行锁，否则使用表级锁<br />当表中锁定其中的某几行时，不同的事务可以使用不同的索引锁定不同的行。另外，不论使用主键索引、唯一索引还是普通索引，InnoDB都会使用行锁来对数据加锁。</p><h3 id="4-隔离级别和锁的关系"><a href="#4-隔离级别和锁的关系" class="headerlink" title="4.隔离级别和锁的关系"></a>4.隔离级别和锁的关系</h3><ul><li>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</li><li>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁； </li><li>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</li><li>SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</li></ul><h3 id="5-锁优化的意见"><a href="#5-锁优化的意见" class="headerlink" title="5.锁优化的意见"></a>5.锁优化的意见</h3><ul><li>不要使用超过实际要求级别的锁</li><li>尽量使用索引访问数据，加锁更加精确</li><li>数据查询非必要不加锁</li></ul><h3 id="6-意向锁是什么"><a href="#6-意向锁是什么" class="headerlink" title="6.意向锁是什么"></a>6.意向锁是什么</h3><p>意向锁是表级锁，用于给表加表锁时，判断有没有数据行被锁定<br />意向插入锁表示事务想在表中某个位置插入数据</p><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="1-分表分库"><a href="#1-分表分库" class="headerlink" title="1.分表分库"></a>1.分表分库</h3><h6 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h6><p>将一个表的数据按照某个字段分成不同的表</p><h6 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h6><p>将一个库的数据分成几个库来存储<br />都是为了提到SQL语句的执行性能，提高并发量</p><h3 id="2-水平拆分和垂直拆分"><a href="#2-水平拆分和垂直拆分" class="headerlink" title="2.水平拆分和垂直拆分"></a>2.水平拆分和垂直拆分</h3><h6 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h6><p>水平拆分的意思，就是把一个表的数据给弄到多个库的多个表里去，但是每个库的表结构都一样，只不 过每个库表放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义，就是将数据均 匀放更多的库里，然后用多个库来抗更高的并发，还有就是用多个库的存储容量来进行扩容。</p><h6 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h6><p>垂直拆分的意思，就是把一个有很多字段的表给拆分成多个表，或者是多个库上去。每个库表的结 构都不一样，每个库表都包含部分字段。一般来说，会将较少的访问频率很高的字段放到一个表里 去，然后将较多的访问频率很低的字段放到另外一个表里去。因为数据库是有缓存的，你访问频率 高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="1-数据库优化是什么"><a href="#1-数据库优化是什么" class="headerlink" title="1.数据库优化是什么"></a>1.数据库优化是什么</h3><p>MySQL数据库优化是多方面的，原则是减少系统的瓶颈，减少资源的占用，增加系统的反应速度</p><h3 id="2-该如何优化MySQL的查询？"><a href="#2-该如何优化MySQL的查询？" class="headerlink" title="2.该如何优化MySQL的查询？"></a>2.该如何优化MySQL的查询？</h3><ol><li>使用索引查询</li><li>使用连接或子查询来优化</li></ol><h3 id="3-怎样插入数据才能更高效？"><a href="#3-怎样插入数据才能更高效？" class="headerlink" title="3.怎样插入数据才能更高效？"></a>3.怎样插入数据才能更高效？</h3><p>对于InnoDB引擎的表，常见的优化方法如下：</p><ol><li>禁用唯一性检查</li></ol><p>插入数据之前执行set unique_checks&#x3D;0来禁止对唯一索引的检查，数据导入完成之后再运行set unique_checks&#x3D;1。这个和MyISAM引擎的使用方法一样。</p><ol start="2"><li>禁用外键检查插入</li></ol><p>数据之前执行禁止对外键的检查，数据插入完成之后再恢复对外键的检查。</p><ol start="3"><li>禁用自动提交</li></ol><p>插入数据之前禁止事务的自动提交，数据导入完成之后，执行恢复自动提交操作。</p><h3 id="4-表中包含几千万条数据该怎么办？"><a href="#4-表中包含几千万条数据该怎么办？" class="headerlink" title="4.表中包含几千万条数据该怎么办？"></a>4.表中包含几千万条数据该怎么办？</h3><ol><li>优化SQL和索引；</li><li>增加缓存，如memcached、redis；</li><li>读写分离，可以采用主从复制，也可以采用主主复制；</li><li>使用MySQL自带的分区表，这对应用是透明的，无需改代码，但SQL语句是要针对分区表做优化的；</li><li>做垂直拆分，即根据模块的耦合度，将一个大的系统分为多个小的系统；</li><li>做水平拆分，要选择一个合理的sharding key，为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表。</li></ol><h3 id="5-MySQL的慢查询优化有了解吗？"><a href="#5-MySQL的慢查询优化有了解吗？" class="headerlink" title="5.MySQL的慢查询优化有了解吗？"></a>5.MySQL的慢查询优化有了解吗？</h3><ol><li>开启慢查询日志</li></ol><p>在配置中设置</p><ol start="2"><li>分析慢查询日志</li></ol><p>直接分析mysql慢查询日志，利用explain关键字可以模拟优化器执行SQL查询语句，来分析sql慢查询语句。</p><ol start="3"><li>优化慢查询<ul><li>通过explain查看索引起没起作用，没有的话考虑增加索引</li><li>索引是否合理，可以建立联合索引，实现覆盖索引优化</li><li>优化表的结构，把一些使用频率比较低的字段分开来</li><li>分解联表查询，进行单表查询</li><li>优化LIMIT分页，不要直接查所有字段，而是根据索引查范围，再查所有字段</li></ul></li></ol><p>SQL的优化：</p><ol><li>开启慢查询配置</li><li>通过explain关键字进行慢查询分析</li><li>分析是否使用索引，索引失效的原因</li><li>索引是否合理</li></ol><h3 id="6-优化慢SQL的方式"><a href="#6-优化慢SQL的方式" class="headerlink" title="6.优化慢SQL的方式"></a>6.优化慢SQL的方式</h3><ol><li>只查询需要的列</li><li>正确使用索引，确保索引生效</li><li>数据量比较大时采用分页查询</li></ol><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><h3 id="1-读写分离"><a href="#1-读写分离" class="headerlink" title="1.读写分离"></a>1.读写分离</h3><p>将数据库的读写操作分散到不同的节点上<br />搭建主从集群，主机负责读写操作，从机负责读操作</p>]]></content>
      
      
      <categories>
          
          <category> 八股 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八股 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/xingliu-test/2024/03/11/Redis/"/>
      <url>/xingliu-test/2024/03/11/Redis/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="Redis展开"><a href="#Redis展开" class="headerlink" title="Redis展开"></a>Redis展开</h1><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>redis的事务是一系列串行化的命令，在执行过程中不受其它事务的影响。<br /><strong>四个命令来实现：</strong><br />MULTI：它标记了一个事务块的开始。MULTI命令之后的所有命令不会立即执行，而是缓存在服务器的一个事务队列中，然后当EXEC命令被调用时一次性、按顺序地执行。<br />EXEC：它标记事务的提交，它的作用是触发服务器执行所有在MULTI之后入队的命令。<br />DISCARD：如果客户端在MULTI之后决定取消事务，那么它可以调用DISCARD命令来做这件事。调用DISCARD之后，服务器会清空事务队列，并将客户端的状态从事务状态调整回非事务状态。<br />WATCHkey[key.]：WATCH命令用于在执行事务前监控一个或多个键，以此来达到乐观锁的效果。如果在调用EXEC命令执行事务之前，有其他客户端抢先对任何一个被监视的键进行了替换、更新、删除等操作，那么当客户端尝试执行事务时，服务器将返回一个错误，客户端可以在这时选择重试事务或者放弃事务。<br /><strong>事务可能的两种情况：</strong></p><ul><li>事务过程出现语法错误，事务提交时无法执行。</li><li>事务过程出现非语法错误，比如set值不存在，则跳过错误语句，其他的语句执行不受影响。</li></ul><p><strong>watch命令：</strong>提供乐观锁机制；事务开启前监控key，如果发生了改变，那么对于这个key操作的事务将不会成功。</p><h3 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁&amp;悲观锁"></a>乐观锁&amp;悲观锁</h3><p><strong>乐观锁：</strong>事务开始前先假设没有人会修改，在提交时则检查是否存在修改，事务回滚耗费时间。<br /><strong>悲观锁：</strong>事务一开始就进行加锁，认定一定会有人修改，对于并发不友好。</p><h3 id="Redis操作方式"><a href="#Redis操作方式" class="headerlink" title="Redis操作方式"></a>Redis操作方式</h3><h6 id="jedis方式"><a href="#jedis方式" class="headerlink" title="jedis方式"></a>jedis方式</h6><p>查看AI助手手机验证登录功能<br /><a href="https://www.yuque.com/yuqueyonghu00040s/ikkvco/hpbrb4h4k13hu75k">AI助手</a></p><h6 id="redisTemplate"><a href="#redisTemplate" class="headerlink" title="redisTemplate"></a>redisTemplate</h6><p>底层实现：在SpringBoot2.x版本以后，从原来的jedis替换成了lettuce，所以2.x以后开始默认使用Lettuce作为Redis客户端，Lettuce客户端基于Netty的NIO框架实现，只需要维持单一的连接即可高效支持业务端并发请求。同时，Lettuce支持的特性更加全面，其性能表现并不逊于，甚至优于Jedis。<br />简单理解：</p><ul><li>Jedis：采用的直连，多个线程操作的话，是不安全的，如果想要避免线程安全问题，就需要使用jedisPool连接池，但是也会有一些线程过多等其他问题，类似于BIO</li><li>Lettuce：底层采用Netty，实例可以在多个线程中进行共享，不存在线程安全问题！类似NIO</li></ul><p><a href="https://zhuanlan.zhihu.com/p/419345478">JAVA BIO与NIO、AIO的区别(容易理解)</a></p><h1 id="Redis面试题"><a href="#Redis面试题" class="headerlink" title="Redis面试题"></a>Redis面试题</h1><h3 id="1-Redis有哪些数据类型？"><a href="#1-Redis有哪些数据类型？" class="headerlink" title="1.Redis有哪些数据类型？"></a>1.Redis有哪些数据类型？</h3><p><a href="https://blog.csdn.net/qq_31960623/article/details/117911710">Redis八种数据类型及应用场景介绍_redis中数据类型的应用场景-CSDN博客</a></p><ol><li>String<br />最基本也是最常用的数据类型就是String。get和set命令就是String的操作命令<br />应用场景：热点数据的缓存、分布式数据的共享（session）、分布式锁、计数器 </li><li>Hash<br />key(map_key,map_value) <blockquote><p>优点：</p><ul><li>把所有相关的值聚集到一个Key中，节省内存空间</li><li>只使用一个Key，减少Key冲突</li><li>当需要批量获取值的时候，只需要使用一个命令，减少内存&#x2F;IO&#x2F;CPU的消耗</li></ul></blockquote>缺点：<blockquote><ul><li>Field不能单独设置过期时间</li><li>需要考虑数据量分布的问题（field非常多的时候，无法分布到多个节点）</li></ul></blockquote></li></ol><p>String能做的Hash都能做 + 购物车 </p><ol start="3"><li>List<br />使用双向链表的结构，可以两端进行出队进队<br />应用场景：列表，存储消息列表；队列&#x2F;栈，当作分布式环境的队列&#x2F;栈使用 </li><li>Set<br />存储 String 类型的无序集合，不含重复元素的list，底层是一个value为null的hash表<br />应用场景：抽奖、签到、点赞 </li><li>ZSet<br />有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集<br />不同之处是有序集合的每个成员都关联了一个评分（score），这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了。<br />可以很快的访问中间元素<br />应用场景：排行榜<br />zset底层使用了hash和跳跃表两种结构</li></ol><p>使用部分节点来构建新链表，在稀疏链表找，一直找到底层链表，直到找到<br>6.  BitMaps<br />BitMaps是在字符串类型上定义的位操作，一个字节由8个二进制位组成，应用于在线用户统计等<br>7.  Hyperloglog<br />Hyperloglog 提供了一种不太精确的基数统计方法，用来统计一个集合中不重复的元素个数，比如统计网站的UV，或者应用的日活、月活，存在一定的误差<br>8.  Geospatial<br />保存经纬度，地理位置信息<br>9.  Streams<br />5.0推出的数据类型。支持多播的可持久化的消息队列，用于实现发布订阅功能，借鉴了Kafka的设计 </p><h3 id="2-Redis为什么这么快"><a href="#2-Redis为什么这么快" class="headerlink" title="2. Redis为什么这么快"></a>2. Redis为什么这么快</h3><ul><li>Redis是基于内存操作，需要的时候需要我们手动持久化到硬盘中（<strong>主要原因</strong>）</li><li>Redis高效数据结构，对数据的操作也比较简单 </li><li>Redis是单线程模型，从而避开了多线程中上下文频繁切换的操作 </li><li>使用多路I&#x2F;O复用模型，非阻塞I&#x2F;O </li><li>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求</li></ul><h3 id="3-set和zset有什么区别？"><a href="#3-set和zset有什么区别？" class="headerlink" title="3.set和zset有什么区别？"></a>3.set和zset有什么区别？</h3><p>set：</p><ul><li>集合中的元素是无序、不可重复的，一个集合最多能存储232-1个元素；</li><li>集合除了支持对元素的增删改查之外，还支持对多个集合取交集、并集、差集。</li></ul><p>zset：</p><ul><li>有序集合保留了集合元素不能重复的特点；</li><li>有序集合会给每个元素设置一个分数，并以此作为排序的依据；</li><li>有序集合不能包含相同的元素，但是不同元素的分数可以相同。</li></ul><h3 id="4-缓存几兄弟"><a href="#4-缓存几兄弟" class="headerlink" title="4.缓存几兄弟"></a>4.缓存几兄弟</h3><h5 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h5><p>同一时间内出现了大量的缓存key过期，原本应该访问缓存的请求同时去访问数据库，造成数据库访问压力增大。</p><blockquote><p>使用加锁的方式；使用队列的请求顺序；最简单的控制失效时间错开，加上一个随机值；真的一定发生雪崩，可以使用熔断机制，不响应部分用户的请求，保证一部分用户可用</p></blockquote><h5 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h5><p>用户要查询的数据在数据库中就没有，缓存中自然也没有，但是请求还是会分别查缓存和数据库一次。</p><blockquote><ol><li>把无效的Key存进Redis中，设置value&#x3D;”null”，并设置一个短时间的过期时间，如果每次key不一样则此方法有问题。 </li><li>使用布隆过滤器，先进行筛选，它认为不存在的key那就一定不存在。引入k&gt;1个hash函数，有一个hash函数说不存在，那就不存在，所有的hash函数说存在，才存在。<br /><a href="https://blog.csdn.net/qq_41125219/article/details/119982158">布隆(Bloom Filter)过滤器——全面讲解，建议收藏-CSDN博客</a></li></ol></blockquote><h5 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h5><p>某个热点的key失效了，导致大并发集中打在数据库上。</p><blockquote><p>如果可以，设置热点key永不失效；加互斥锁，拿到锁才能查询数据库。</p></blockquote><h5 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h5><p>系统上线后，提前将一些数据加入到缓存中。</p><ol><li>手写缓存刷新页面，手工操作</li><li>项目启动的时候自动加载</li><li>定时缓存刷新</li></ol><h5 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h5><p>自定义缓存更新策略</p><ol><li>定期清理过期的缓存，维护大量的key比较麻烦。</li><li>请求过来时再更新缓存，每次请求都要判断比较麻烦。</li></ol><h5 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h5><p>访问量剧增或服务出现问题时，保证核心业务可以继续使用，降低一些服务的级别</p><h3 id="5-Redis怎么实现分布式锁"><a href="#5-Redis怎么实现分布式锁" class="headerlink" title="5.Redis怎么实现分布式锁"></a>5.Redis怎么实现分布式锁</h3><p>setnx命令返回整数值，当返回1时表示设置值成功，当返回0时表示设置值失败（key已存在）。<br />加锁：<br />第一版，这种方式的缺点是容易产生死锁，因为客户端有可能忘记解锁，或者解锁失败。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setnx key value</span><br></pre></td></tr></table></figure><p>第二版，给锁增加了过期时间，避免出现死锁。但这两个命令不是原子的，第二步可能会失败，依然无法避免死锁问题。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setnx key value expire key seconds</span><br></pre></td></tr></table></figure><p>第三版，通过“set…nx…”命令，将加锁、过期命令编排到一起，它们是原子操作了，可以避免死锁。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set key value nx ex seconds</span><br></pre></td></tr></table></figure><p>解锁：<br />解锁就是删除代表锁的那份数据。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">del key</span><br></pre></td></tr></table></figure><p>还存在问题就是会释放别人的锁<br />想要解决这个问题，我们需要解决两件事情：</p><ol><li>在加锁时就要给锁设置一个标识，进程要记住这个标识。当进程解锁的时候，要进行判断，是自己持有的锁才能释放，否则不能释放。可以为key赋一个随机值，来充当进程的标识。</li><li>解锁时要先判断、再释放，这两步需要保证原子性，否则第二步失败的话，就会出现死锁。而获取和删除命令不是原子的，这就需要采用Lua脚本，通过Lua脚本将两个命令编排在一起，而整个Lua脚本的执行是原子的。</li></ol><p>按照以上思路，优化后的命令如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 加锁 set key random-value nx ex seconds   # 解锁 <span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then     <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>]) e</span><br></pre></td></tr></table></figure><p>这个不是很详细，建议看语雀笔记<br />基于RedLock算法的分布式锁：<br />上述分布式锁的实现方案，是建立在单个主节点之上的。它的潜在问题如下图所示，如果进程A在主节点上加锁成功，然后这个主节点宕机了，则从节点将会晋升为主节点。若此时进程B在新的主节点上加锁成功，之后原主节点重启，成为了从节点，系统中将同时出现两把锁，这是违背锁的唯一性原则的。<br />总之，就是在单个主节点的架构上实现分布式锁，是无法保证高可用的。若要保证分布式锁的高可用，则可以采用多个节点的实现方案。这种方案有很多，而Redis的官方给出的建议是采用RedLock算法的实现方案。该算法基于多个Redis节点，它的基本逻辑如下：</p><ul><li>这些节点相互独立，不存在主从复制或者集群协调机制；</li><li>加锁：以相同的KEY向N个实例加锁，只要超过一半节点成功，则认定加锁成功；</li><li>解锁：向所有的实例发送DEL命令，进行解锁；</li></ul><p>RedLock是对多个节点一起加锁，解锁也是一起解锁。</p><h3 id="6-Redis的持久化策略"><a href="#6-Redis的持久化策略" class="headerlink" title="6.Redis的持久化策略"></a>6.Redis的持久化策略</h3><p>为了能够重用Redis的数据，或者防止系统故障，我们需要将数据写入到磁盘空间中，即持久化<br />快照<code>RDB</code>，只追加文件<code>AOF</code>。</p><h6 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h6><p>RDB持久化策略是指在一定的时间间隔内，将Redis内存中的数据以二进制文件的形式保存到硬盘上。这个二进制文件就是一个快照，它记录了某个时刻Redis内存中的所有数据。RDB持久化策略可以通过配置文件或者命令来触发，配置文件中可以设置多个条件，当任意一个条件满足时，就会执行一次快照操作。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save 900 1 # 900秒内执行一次 set 操作 则持久化1次</span><br><span class="line">save 300 10 # 300秒内执行10次 set 操作,则持久化1次</span><br><span class="line">save 60 10000 # 60秒内执行10000次 set 操作,则持久化1次</span><br></pre></td></tr></table></figure><p>命令有两种：</p><ul><li><strong>save</strong>：不建议使用，会阻塞redis服务的进程，直到成功创建RDB文件</li><li><strong>bgsave</strong>：父进程创建一个子进程生成RDB文件，父进程可以正常处理客户端的指令，<strong>不影响主进程</strong>的服务</li></ul><p>RDB持久化策略的优点有：</p><ul><li>RDB文件是一个紧凑的二进制文件，占用空间小，传输速度快，适合做备份和灾难恢复</li><li>RDB文件恢复数据的速度比AOF快，因为只需要加载一次文件即可</li><li>RDB持久化对Redis服务器的性能影响较小，因为大部分工作由子进程完成</li></ul><p>RDB持久化策略的缺点有：</p><ul><li>如果在两次快照之间发生故障，可能会丢失一部分数据</li><li>RDB文件在生成过程中可能会占用较多的内存和CPU资源，因为需要复制主进程的内存并执行压缩操作</li></ul><h6 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h6><p>以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，Redis启动之初会读取该文件重新构建数据，换言之，Redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。<br />AOF采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集.。<br />三种刷盘策略： </p><ul><li>每修改同步：appendfsync always 同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好</li><li>每秒同步：appendfsync everysec 异步操作，每秒记录，如果一秒内宕机，有数据丢失</li><li>不同步：appendfsync no从不同步，刷盘时间由redis决定</li></ul><p>AOF持久化策略的优点有：</p><ul><li>AOF文件可以实时或者近实时地记录Redis内存中的数据，因为它是每次写命令或者每秒钟同步一次。如果在同步之间发生故障，可能会丢失一部分数据，但是数据丢失的概率比RDB小。</li><li>AOF文件是一个文本文件，可以方便地查看和编辑。AOF文件中的命令是Redis协议格式的，可以直接用Redis客户端来执行。</li><li>AOF文件可以自动进行重写，以减少冗余命令和文件体积。重写过程不影响Redis服务器的正常服务，也不会丢失任何数据。</li></ul><p>AOF持久化策略的缺点有：</p><ul><li>AOF文件通常比RDB文件大，占用更多的磁盘空间</li><li>AOF文件恢复数据的速度比RDB慢，因为需要重新执行所有的命令</li><li>AOF文件在写入过程中可能会出现数据不一致的情况，例如命令只写入了一半或者写入了错误的命令。这种情况下需要用redis-check-aof工具来修复AOF文件</li></ul><p><strong>AOF重写机制：</strong>Redis会创建一个新的AOF文件，然后根据内存中的当前数据状态，生成相应的写命令，并写入到新的AOF文件中。这样新的AOF文件就只包含了最终数据的写命令，而不包含任何无效或者冗余的命令。<br />在重写期间，会将接收到的写命令写到缓冲区，在执行完毕后追加到新的AOF文件，最后替换旧的AOF文件</p><ul><li><p>自动触发：通过参数设置</p><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"># 文件大小超过上次AOF重写之后的文件的百分比。默认<span class="number">100</span></span><br><span class="line"># 也就是默认达到上一次AOF重写文件的<span class="number">2</span>倍之后会再次触发AOF重写</span><br><span class="line"><span class="keyword">auto</span>-aof-rewrite-percentage <span class="number">100</span></span><br><span class="line"># 设置允许重写的最小AOF文件大小,默认是<span class="number">64</span>M</span><br><span class="line"># 主要是避免满足了上面的百分比，但是文件还是很小的情况。</span><br><span class="line"><span class="keyword">auto</span>-aof-rewrite-min-size <span class="number">64</span>mb</span><br></pre></td></tr></table></figure></li><li><p>手动触发：bgrewriteaof命令</p></li></ul><h6 id="RDB-AOF混合持久化"><a href="#RDB-AOF混合持久化" class="headerlink" title="RDB-AOF混合持久化"></a>RDB-AOF混合持久化</h6><p>Redis从4.0开始引入RDB-AOF混合持久化模式，这种模式是基于AOF持久化构建而来的。用户可以通过配置文件中的“aof-use-rdb-preamble yes”配置项开启AOF混合持久化。Redis服务器在执行AOF重写操作时，会按照如下原则处理数据： </p><ul><li>像执行BGSAVE命令一样，根据数据库当前的状态生成相应的RDB数据，并将其写入AOF文件中；</li><li>对于重写之后执行的Redis命令，则以协议文本的方式追加到AOF文件的末尾，即RDB数据之后。</li></ul><p>通过使用RDB-AOF混合持久化，用户可以同时获得RDB持久化和AOF持久化的优点，服务器既可以通过AOF文件包含的RDB数据来实现快速的数据恢复操作，又可以通过AOF文件包含的AOF数据来将丢失数据的时间窗口限制在1s之内。 </p><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/reim/p/17387751.html">Redis的三种持久化策略及选取建议 - 阿磊聊软件 - 博客园</a></p><h3 id="7-Redis的高可用实现方案"><a href="#7-Redis的高可用实现方案" class="headerlink" title="7.Redis的高可用实现方案"></a>7.Redis的高可用实现方案</h3><h6 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h6><p>Redis Sentinel（哨兵）是一个分布式架构，它包含若干个哨兵节点和数据节点。每个哨兵节点会对数据节点和其余的哨兵节点进行监控，当发现节点不可达时，会对节点做下线标识。如果被标识的是主节点，它就会与其他的哨兵节点进行协商，当多数哨兵节点都认为主节点不可达时，它们便会选举出一个哨兵节点来完成自动故障转移的工作，同时还会将这个变化实时地通知给应用方。整个过程是自动的，不需要人工介入，有效地解决了Redis的高可用问题！<br />哨兵节点包含如下的特征：</p><ol><li><strong>哨兵节点会定期监控数据节点，其他哨兵节点是否可达</strong>；</li><li>哨兵节点会将故障转移的结果通知给应用方；</li><li><strong>哨兵节点可以将从节点晋升为主节点，并维护后续正确的主从关系</strong>；</li><li>哨兵模式下，客户端连接的是哨兵节点集合，从中获取主节点信息；</li><li>节点的故障判断是由多个哨兵节点共同完成的，可有效地防止误判；</li><li>哨兵节点集合是由多个哨兵节点组成的，即使个别哨兵节点不可用，整个集合依然是健壮的；</li><li>哨兵节点也是独立的Redis节点，是特殊的Redis节点，它们不存储数据，只支持部分命令。</li></ol><p>主节点和从节点都储存一样的信息，主节点有读写权限，从节点只有读权限，造成内存的浪费</p><h6 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h6><p>Redis集群采用虚拟槽分区来实现数据分片，每一个节点负责维护一部分槽以及槽所映射的键值数据。最小配置6个节点以上，主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。<br />哨兵是整个的数据库作为主从，集群则进行分片，对于每一片保留一个备份，大大减少了内存使用。</p><h3 id="8-Redis的主从同步是如何实现的"><a href="#8-Redis的主从同步是如何实现的" class="headerlink" title="8.Redis的主从同步是如何实现的"></a>8.Redis的主从同步是如何实现的</h3><p>从2.8版本开始，Redis使用psync命令完成主从数据同步，同步过程分为全量复制和部分复制。前者一般是用于初次复制的场景，部分复制则用于处理因网络中断等原因造成数据丢失的场景。<br />复制过程：</p><ul><li>从节点发送给主节点psync命令，返回全量复制</li><li>主节点接收到SYNC命令后，可以执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令。</li><li>主节点生成快照后发送给从节点，并记录所有写操作。</li><li>在从节点载入快照后，执行来自主节点缓冲区的写命令</li><li>出现断开重连后，2.8之后的版本会将断线期间的命令传给从数据库，增量复制。</li><li><strong>主从刚刚连接的时候，进行全量同步;全同步结束后，进行增量同步</strong>。当然，如果有需要，slave在任何时候都可以发起全量同步。Redis的策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</li></ul><h3 id="9-Redis过期键的删除策略"><a href="#9-Redis过期键的删除策略" class="headerlink" title="9.Redis过期键的删除策略"></a>9.Redis过期键的删除策略</h3><p>Redis支持如下两种过期策略：<br />惰性删除：客户端访问一个key的时候，Redis会先检查它的过期时间，如果发现过期就立刻删除这个key。<br />定期删除：Redis会将设置了过期时间的key放到一个独立的字典中，并对该字典进行每秒10次的过期扫描<br />1、定时删除<br />在设置某个key的过期时间同时，我们创建一个定时器，让定时器在该过期时间到来时，立即执行对其进行删除的操作。<br />优点：定时删除对内存是最友好的，能够保存内存的key一旦过期就能立即从内存中删除。<br />缺点：对CPU最不友好，在过期键比较多的时候，删除过期键会占用一部分CPU时间，对服务器的响应时间和吞吐量造成影响。<br />2、惰性删除<br />设置该key过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key。</p><blockquote><p>访问或修改前，都会调用expireIfNeeded函数检查key是否过期，如果过期就删除key，同步还是异步删除由参数配置决定</p></blockquote><p>优点：对CPU友好，我们只会在使用该键时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查。<br />缺点：对内存不友好，如果一个键已经过期，但是一直没有使用，那么该键就会一直存在内存中，如果数据库中有很多这种使用不到的过期键，这些键便永远不会被删除，内存永远不会释放。从而造成内存泄漏。<br />3、定期删除<br />每隔一段时间，随机从数据库中取出一定数量的key进行检查，并删除里面过期的key。（间隔检查时间是一个参数设置hz，随机抽查数量写死在代码：20）<br />优点：可以通过限制删除操作执行的时长和频率来减少删除操作对CPU 的影响。另外定期删除，也能有效释放过期键占用的内存。</p><h3 id="10-如何保证缓存与数据库的双写一致性？"><a href="#10-如何保证缓存与数据库的双写一致性？" class="headerlink" title="10.如何保证缓存与数据库的双写一致性？"></a>10.如何保证缓存与数据库的双写一致性？</h3><ol><li>先更新缓存，再更新数据库；</li><li>先更新数据库，再更新缓存；</li><li>先删除缓存，再更新数据库；</li><li>先更新数据库，再删除缓存。</li></ol><p>第一种如果更新缓冲成功，更新数据库失败，数据不一致<br />第二种在并发场景下，会把脏数据更新到数据库<br />第三种，A进行写操作，删除缓存；B进行查操作，缓存没查到，去数据库查，并写到缓存中；A把数据写入到数据库中，出现数据不一致。<br />延时双删：在更新数据库后，sleep一下（给B的查询更新缓存操作留时间），再进行缓存删除<br />第四种，A更新数据库成功，删除缓存失败，数据不一致。<br />重试机制，再次进行删除缓存<br />通常我们选择直接删除缓存，因为缓存的更新成本更高（很多情况下并不是直接写入缓存的，而是经过一系列负责的计算再写入缓存）<br />通常我们选择先操作数据库，再删除缓存，虽然这两种都会可能出现数值不一致性问题，但是前面这种更能保证数据的最终一致性，不同的顺序都会出现不一样的问题，详细可以看上面的解释<br /><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/43109882/1715159198724-beb74ce3-b9af-4317-9403-6b9e4d6e6432.jpeg"><br /><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/43109882/1715159487542-95bb79fa-b554-4d04-a4fe-4e94afd1e092.jpeg"></p><h3 id="11-Redis集群"><a href="#11-Redis集群" class="headerlink" title="11.Redis集群"></a>11.Redis集群</h3><h6 id="分区方案"><a href="#分区方案" class="headerlink" title="分区方案"></a>分区方案</h6><p>Redis集群采用虚拟槽分区来实现数据分片，它把所有的键根据哈希函数映射到0-16383整数槽内，计算公式为slot&#x3D;CRC16(key)&amp;16383，每一个节点负责维护一部分槽以及槽所映射的键值数据。虚拟槽分区具有如下特点：</p><ol><li>解耦数据和节点之间的关系，简化了节点扩容和收缩的难度；</li><li>节点自身维护槽的映射关系，不需要客户端或者代理服务维护槽分区元数据；</li><li>支持节点、槽、键之间的映射查询，用于数据路由，在线伸缩等场景。</li></ol><h6 id="通信方案"><a href="#通信方案" class="headerlink" title="通信方案"></a>通信方案</h6><p>Redis cluster节点间采取gossip协议进行通信，所有节点都持有一份元数据，不同的节点如果出现了元数据的变更之后不断地将元数据发送给其他节点让其他节点进行数据变更。<br />这种机制的好处在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续，打到所有节点上去更新，有一定的延时，降低了压力;<br />缺点，元数据更新有延时，可能导致集群的一些操作会有一些滞后。</p><h6 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h6><p>Redis Cluster是Redis的分布式解决方案，在3.0版本正式推出，有效地解决了Redis分布式方面的需求。当遇到单机内存、并发、流量等瓶颈时，可以采用Cluster架构方案达到负载均衡的目的。</p><h6 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h6><ul><li>key批量操作支持有限，只支持映射为相同slot的操作</li><li>只支持同一节点的事务操作</li><li>单机Redis有16个数据库，集群下只有一个，DB0</li><li>…</li></ul><h3 id="12-说一说hash和zset类型底层的数据结构"><a href="#12-说一说hash和zset类型底层的数据结构" class="headerlink" title="12.说一说hash和zset类型底层的数据结构"></a>12.说一说hash和zset类型底层的数据结构</h3><p>哈希对象有两种编码方案，当同时满足以下条件时，哈希对象采用ziplist编码，否则采用hashtable编码：</p><ul><li>哈希对象保存的键值对数量小于512个；</li><li>哈希对象保存的所有键值对中的键和值，其字符串长度都小于64字节。</li></ul><p>其中，ziplist编码采用压缩列表作为底层实现，而hashtable编码采用字典作为底层实现。<br />压缩列表：<br />压缩列表（ziplist），是Redis为了节约内存而设计的一种线性数据结构，它是由一系列具有特殊编码的连续内存块构成的。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或一个整数值。<br />字典：<br />字典（dict）又称为散列表，是一种用来存储键值对的数据结构。</p><p>有序集合对象有2种编码方案，当同时满足以下条件时，集合对象采用ziplist编码，否则采用skiplist编码：</p><ul><li>有序集合保存的元素数量不超过128个；</li><li>有序集合保存的所有元素的成员长度都小于64字节。</li></ul><p>其中，ziplist编码的有序集合采用压缩列表作为底层实现，skiplist编码的有序集合采用zset结构作为底层实现。zset对象的底层数据结构包括：压缩列表、字典、跳跃表。</p><h3 id="13-布隆过滤器的理解"><a href="#13-布隆过滤器的理解" class="headerlink" title="13.布隆过滤器的理解"></a>13.布隆过滤器的理解</h3><p>布隆过滤器可以用很低的代价，估算出数据是否真实存在。例如：给用户推荐新闻时，要去掉重复的新闻，就可以利用布隆过滤器，判断该新闻是否已经推荐过。<br />布隆过滤器的核心包括两部分：</p><ol><li>一个大型的位数组；</li><li>若干个不一样的哈希函数，每个哈希函数都能将哈希值算的比较均匀。</li></ol><p>布隆过滤器的工作原理：</p><ol><li>添加key时，每个哈希函数都利用这个key计算出一个哈希值，再根据哈希值计算一个位置，并将位数组中这个位置的值设置为1。</li><li>询问key时，每个哈希函数都利用这个key计算出一个哈希值，再根据哈希值计算一个位置。然后对比这些哈希函数在位数组中对应位置的数值：<ul><li>如果这几个位置中，有一个位置的值是0，就说明这个布隆过滤器中，不存在这个key。</li><li>如果这几个位置中，所有位置的值都是1，就说明这个布隆过滤器中，极有可能存在这个key。之所以不是百分之百确定，是因为也可能是其他的key运算导致该位置为1。</li></ul></li></ol><h3 id="14-Redis抗高并发访问怎么设计-如果并发量超过30万，怎么设计Redis架构？"><a href="#14-Redis抗高并发访问怎么设计-如果并发量超过30万，怎么设计Redis架构？" class="headerlink" title="14.Redis抗高并发访问怎么设计 &amp; 如果并发量超过30万，怎么设计Redis架构？"></a>14.Redis抗高并发访问怎么设计 &amp; 如果并发量超过30万，怎么设计Redis架构？</h3><p>使用集群架构方案，将Redis分为不同的槽，由不同的节点进行负责，高并发访问时将key映射到不同的节点，防止对同一节点进行高并发访问冲击。</p><h3 id="15-Redis的缓存淘汰策略"><a href="#15-Redis的缓存淘汰策略" class="headerlink" title="15.Redis的缓存淘汰策略"></a>15.Redis的缓存淘汰策略</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/43109882/1715683513000-9f204e56-0474-42b2-835b-ce12211fbc14.jpeg"><br />个人总结</p><ul><li>利用LRU算法，淘汰哪些设置了过期时间的最近被使用的key</li><li>利用LFU算法，淘汰哪些设置了过期时间的最近最少被使用的key</li><li>从设置了过期时间的key中挑选即将过期的数据淘汰</li><li>从数据集中挑选任意key淘汰</li><li>不允许写</li></ul><h3 id="16-Redis为何选择单线程"><a href="#16-Redis为何选择单线程" class="headerlink" title="16.Redis为何选择单线程"></a>16.Redis为何选择单线程</h3><ul><li>单线程避免多线程切换开销</li><li>避免了同步机制的开销，比如锁</li><li>实现简单，底层结构不用设置成线程安全的</li></ul><h3 id="17-Redis不是真的是单线程"><a href="#17-Redis不是真的是单线程" class="headerlink" title="17.Redis不是真的是单线程"></a>17.Redis不是真的是单线程</h3><p>1.Redisv4.0（引入多线程处理异步任务）<br />2.Redis6.0（在网络模型中实现多线程I&#x2F;O）<br />所以，网络上说的Redis是单线程，通常是指在Redis 6.0之前，其核心网络模型使用的是单线程<br />且Redis6.0引入多线程I&#x2F;O，只是用来处理网络数据的读写和协议的解析，而执行命令依旧是单线程。<br />例如进行持久时，会先fork()一个子进程，单进程只是说Redis的网络IO和键值对读写是由一个线程来完成的，而其他的功能则是依赖于其他线程来实现的。</p><h3 id="18-Redis6-0开启多线程后，是否会存在线程并发安全问题？"><a href="#18-Redis6-0开启多线程后，是否会存在线程并发安全问题？" class="headerlink" title="18.Redis6.0开启多线程后，是否会存在线程并发安全问题？"></a>18.Redis6.0开启多线程后，是否会存在线程并发安全问题？</h3><p>从实现机制可以看出，Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行。<br />所以我们不需要去考虑控制Key、Lua、事务，LPUSH&#x2F;LPOP 等等的并发及线程安全问题。</p><h3 id="19-Redis事务的概念"><a href="#19-Redis事务的概念" class="headerlink" title="19.Redis事务的概念"></a>19.Redis事务的概念</h3><ol><li>Redis事务中如果有某一条命令执行失败，之前的命令不会回滚，其后的命令仍然会被继续执行。鉴于这个原因，所以说Redis的事务严格意义上来说是不具备原子性的。</li><li>Redis事务中所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li><li>在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行。</li></ol><h3 id="20-Redis事务的三个阶段"><a href="#20-Redis事务的三个阶段" class="headerlink" title="20.Redis事务的三个阶段"></a>20.Redis事务的三个阶段</h3><ol><li>multi开启事务</li><li>大量指令入队</li><li>exec执行事务块内命令，截止此处一个事务已经结束</li><li>discard 取消事务</li><li>watch 监视一个或多个key，如果事务执行前key被改动，事务将打断。unwatch 取消监视</li></ol><p>事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排队</p><h3 id="21-Redis事务支持隔离性吗"><a href="#21-Redis事务支持隔离性吗" class="headerlink" title="21.Redis事务支持隔离性吗"></a>21.Redis事务支持隔离性吗</h3><p>Redis是单进程的，并且保证在执行命令时不会被其他命令打断，可以完整的执行完一个事务的所有命令，所以天然的具有隔离性</p><h3 id="22-Redis事务的其他实现"><a href="#22-Redis事务的其他实现" class="headerlink" title="22.Redis事务的其他实现"></a>22.Redis事务的其他实现</h3><ul><li>基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完。</li><li>基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐。</li></ul><h3 id="23-Redis为什么不支持事务回滚"><a href="#23-Redis为什么不支持事务回滚" class="headerlink" title="23.Redis为什么不支持事务回滚"></a>23.Redis为什么不支持事务回滚</h3><ul><li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li><li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li></ul><p>watch 机制实现乐观锁，来监视一个或多个 key，如果被监视的 key 在事务执行前被修改过那么本次事务将会被取消，也就是所谓的回滚。</p><h3 id="24-由于主从延迟导致读取到过期数据怎么处理"><a href="#24-由于主从延迟导致读取到过期数据怎么处理" class="headerlink" title="24.由于主从延迟导致读取到过期数据怎么处理"></a>24.由于主从延迟导致读取到过期数据怎么处理</h3><ol><li>通过scan命令扫库：当Redis中的key被scan的时候，相当于访问了该key，同样也会做过期检测，充分发挥Redis惰性删除的策略。这个方法能大大降低了脏数据读取的概率，但缺点也比较明显，会造成一定的数据库压力，否则影响线上业务的效率。</li><li>Redis加入了一个新特性来解决主从不一致导致读取到过期数据问题，增加了key是否过期以及对主从库的判断，如果key已过期，当前访问的master则返回null；当前访问的是从库，且执行的是只读命令也返回null。</li></ol><p>总结：经常扫描，实现类似惰性删除的效果，处理过期数据，这样就降低了访问到过期数据的概率；新特性，访问从节点时，即使key没有过期，返回null。</p><h3 id="25-主从复制的过程中如果因为网络原因停止复制了会怎么样？"><a href="#25-主从复制的过程中如果因为网络原因停止复制了会怎么样？" class="headerlink" title="25.主从复制的过程中如果因为网络原因停止复制了会怎么样？"></a>25.主从复制的过程中如果因为网络原因停止复制了会怎么样？</h3><p>自动重连，从上次复制的地方继续复制下去，如果找不到上次复制的地方（偏移量offset），就进行一次全量复制</p><h3 id="26-主从架构会数据丢失吗？"><a href="#26-主从架构会数据丢失吗？" class="headerlink" title="26.主从架构会数据丢失吗？"></a>26.主从架构会数据丢失吗？</h3><p>脑裂导致的丢失：master突然脱离网络，哨兵认为master出故障了，就选了个新master，然后旧的master回来了，但是它只能作为slave节点加入连接，所以就把数据清空进行全量复制。<br />解决方式：不能避免，只能减少；减少主从节点的连接延迟阈值，超过的话master就不会再接收任何数据了。</p><h3 id="27-RedLock"><a href="#27-RedLock" class="headerlink" title="27.RedLock"></a>27.RedLock</h3><p>RedLock 算法旨在解决单个 Redis 实例作为分布式锁时可能出现的单点故障问题，通过在多个独立运行的 Redis 实例上同时获取锁的方式来提高锁服务的可用性和安全性。<br />RedLock 具备以下主要特性：</p><ul><li><strong>互斥性</strong>：在任何时间，只有一个客户端可以获得锁，确保了资源的互斥访问。</li><li><strong>避免死锁</strong>：通过为锁设置一个较短的过期时间，即使客户端在获得锁后由于网络故障等原因未能按时释放锁，锁也会因为过期而自动释放，避免了死锁的发生。</li><li><strong>容错性</strong>：即使一部分 Redis 节点宕机，只要大多数节点（即过半数以上的节点）仍在线，RedLock 算法就能继续提供服务，并确保锁的正确性。</li></ul><h6 id="RedLock-实现思路"><a href="#RedLock-实现思路" class="headerlink" title="RedLock 实现思路"></a>RedLock 实现思路</h6><p>RedLock 是对集群的每个节点进行加锁，如果大多数节点（N&#x2F;2+1）加锁成功，则才会认为加锁成功。<br />这样即使集群中有某个节点挂掉了，因为大部分集群节点都加锁成功了，所以分布式锁还是可以继续使用的。</p><h6 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h6><p>RedLock 算法的工作流程大致如下：</p><ul><li>客户端向多个独立的 Redis 实例尝试获取锁，设置锁的过期时间非常短。</li><li>如果客户端能在大部分节点上成功获取锁，并且所花费的时间小于锁的过期时间的一半，那么认为客户端成功获取到了分布式锁。</li><li>当客户端完成对受保护资源的操作后，它需要向所有曾获取锁的 Redis 实例释放锁。</li><li>若在释放锁的过程中，客户端因故无法完成，由于设置了锁的过期时间，锁最终会自动过期释放，避免了死锁。</li></ul><p>在 Java 开发中，可以使用 Redisson 框架很方便的实现 RedLock。</p>]]></content>
      
      
      <categories>
          
          <category> 八股 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八股 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/xingliu-test/2024/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/xingliu-test/2024/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="OSI七层模型-TCP-IP"><a href="#OSI七层模型-TCP-IP" class="headerlink" title="OSI七层模型 &amp; TCP&#x2F;IP"></a>OSI七层模型 &amp; TCP&#x2F;IP</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1714029464726-66837f3b-9a56-4fc6-bbd2-7b8783eb057e.png#averageHue=%23f3f1f1&clientId=ud1d43a64-c737-4&from=paste&id=u07857916&originHeight=468&originWidth=631&originalType=url&ratio=1.6500000953674316&rotation=0&showTitle=false&status=done&style=none&taskId=u7bfd6972-34dc-4659-9fb0-9ed9dede4f6&title="></p><table><thead><tr><th><strong>OSI七层模型</strong></th><th><strong>TCP&#x2F;IP四层模型</strong></th><th><strong>协议</strong></th></tr></thead><tbody><tr><td>应用层 表示层 会话层</td><td>应用层</td><td>HTTP、DNS、SMTP、FTP等</td></tr><tr><td>传输层</td><td>传输层</td><td>TCP&#x2F;UDP</td></tr><tr><td>网络层</td><td>网络层</td><td>IP</td></tr><tr><td>数据链路层 物理层</td><td>链路层</td><td>-</td></tr></tbody></table><ul><li>应用层：主要提供两个终端设备上的应用程序之间信息交换的服务</li><li>传输层：向两台终端设备进程之间的通信提供通用的数据传输服务</li><li>网络层：决定你的数据在网络中的游走路径</li><li>数据链路层：用来进行数据在物理硬件中的传输流程</li></ul><h3 id="输入URL到页面"><a href="#输入URL到页面" class="headerlink" title="输入URL到页面"></a>输入URL到页面</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/43109882/1714029669775-e28fa169-303f-452c-9e29-804b23a96bdd.jpeg#averageHue=%23f7f7f7&clientId=ud1d43a64-c737-4&from=paste&height=462&id=u7ac95ca0&originHeight=914&originWidth=1160&originalType=url&ratio=1.6500000953674316&rotation=0&showTitle=false&status=done&style=none&taskId=u45427546-8c9e-4d2a-a9d5-17025b758c9&title=&width=586.7802734375"></p><ol><li>在浏览器中输入指定网页的 URL。</li><li>浏览器通过 DNS 协议，获取域名对应的 IP 地址。</li><li>浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求。</li><li>浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。</li><li>服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。</li><li>浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。</li><li>浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。</li></ol><h3 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h3><ul><li>端口号不同：HTTP 默认是 80，HTTPS 默认是 443。</li><li>URL前缀不同：前者http:&#x2F;&#x2F;，后者https:&#x2F;&#x2F;。</li><li>安全性：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL&#x2F;TLS 之上的 HTTP 协议，SSL&#x2F;TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li><li>HTTPS 协议需要申请数字证书来保证服务器的身份是可信的</li><li>搜索引擎：因为安全性，通常使用HTTPS协议的网站会被优先展示</li></ul><h3 id="HTTPS工作原理"><a href="#HTTPS工作原理" class="headerlink" title="HTTPS工作原理"></a>HTTPS工作原理</h3><ol><li>客户端发起请求，连接服务端443端口</li><li>服务端将自己的数字证书发送给客户端（公钥在证书里面，私钥由服务器持有）</li><li>客户端收到数字证书之后，会验证证书的合法性。如果证书验证通过，就会生成一个随机的对称密钥，用证书的公钥加密发送给服务端</li><li>服务器用私钥解密得到秘钥，至此完成</li></ol><h3 id="HTTP-1-0-vs-HTTP-1-1"><a href="#HTTP-1-0-vs-HTTP-1-1" class="headerlink" title="HTTP 1.0 vs HTTP 1.1"></a>HTTP 1.0 vs HTTP 1.1</h3><ul><li>状态码：后者增加了大量的状态码</li><li>连接方式：前者短连接，进行一次HTTP操作就建立连接一次；后者长连接，首次建立连接后不会立即关闭，而是会保持一段时间</li><li>Host头：1.1在请求头中增加了host字段，允许多个主机名绑定到一个IP地址上</li></ul><h3 id="HTTP-1-1-vs-HTTP-2-0"><a href="#HTTP-1-1-vs-HTTP-2-0" class="headerlink" title="HTTP 1.1 vs HTTP 2.0"></a>HTTP 1.1 vs HTTP 2.0</h3><ul><li>头部压缩：发送多个请求时，头中重复的部分会被客户端和服务器维护起来，不进行重复发送</li><li>二进制格式：1.1采用文本形式的报文，2.0采用二进制</li><li>并发传输：2.0可以在一个连接上同时传输多个请求和响应</li><li>服务器推送：2.0会将相关资源一起推送给客户端</li></ul><h3 id="HTTP-3-0"><a href="#HTTP-3-0" class="headerlink" title="HTTP 3.0"></a>HTTP 3.0</h3><p>传输层基于UDP协议，并在应用层实现QUIC协议保证UDP传输变为可靠传输<br><a href="https://xiaolincoding.com/network/2_http/http3.html#%E6%80%BB%E7%BB%93">3.7 HTTP&#x2F;3 强势来袭</a></p><h3 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h3><ul><li>根 DNS 服务器。根 DNS 服务器提供 TLD 服务器的 IP 地址。目前世界上只有 13 组根服务器，我国境内目前仍没有根服务器。</li><li>顶级域 DNS 服务器（TLD 服务器）。顶级域是指域名的后缀，如com、org、net和edu等。国家也有自己的顶级域，如uk、fr和ca。TLD 服务器提供了权威 DNS 服务器的 IP 地址。</li><li>权威 DNS 服务器。在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。</li><li>本地 DNS 服务器。每个 ISP（互联网服务提供商）都有一个自己的本地 DNS 服务器。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 层次结构中。严格说来，不属于 DNS 层级结构。</li></ul><h3 id="TCP-三次握手四次挥手"><a href="#TCP-三次握手四次挥手" class="headerlink" title="TCP 三次握手四次挥手"></a>TCP 三次握手四次挥手</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1714033482877-6d21e37d-37d5-43e3-a7cd-36cf597e9b68.png#averageHue=%23f3fcf5&clientId=ud1d43a64-c737-4&from=paste&height=401&id=ua10e1e91&originHeight=583&originWidth=499&originalType=url&ratio=1.6500000953674316&rotation=0&showTitle=false&status=done&style=none&taskId=ue5ec7590-c31d-4937-9f63-1e1498af46f&title=&width=342.9961853027344"><br><strong>为什么三次握手</strong></p><ul><li>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li><li>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li><li>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li></ul><p><strong>三次握手的目的</strong><br>为了防止已失效的连接请求<a href="https://www.zhihu.com/search?q=%E6%8A%A5%E6%96%87%E6%AE%B5&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:63668444%7D">报文段</a>突然又传送到了服务端，因而产生错误<br>四次握手属于是重复，两次握手不行，因为服务端不能确认客户端是否收到了自己的同步信号<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1714034009205-61c8c7e9-163f-48e4-83f6-d5fa23f3959e.png#averageHue=%23f3fcf5&clientId=ud1d43a64-c737-4&from=paste&height=373&id=u63a0ec51&originHeight=583&originWidth=499&originalType=url&ratio=1.6500000953674316&rotation=0&showTitle=false&status=done&style=none&taskId=uc34c179f-9ac7-4cdd-b685-30a28e1fcba&title=&width=318.9961853027344"></p><ul><li>第一次挥手：客户端说我要断开连接</li><li>第二次挥手：服务端知道了并表示可能还有数据传输</li><li>第三次挥手：服务器说我传输完了，可以断开连接</li><li>第四次挥手：客户端表示那就断开连接吧</li></ul><p><strong>不能三次挥手</strong>：因为可能还有数据没传输完<br><strong>第四次挥手客户端需等待2MSL：</strong>防止ack传输失败，服务器会重发，客户端需要重新确认</p><h3 id="TCP传输可靠性保障"><a href="#TCP传输可靠性保障" class="headerlink" title="TCP传输可靠性保障"></a>TCP传输可靠性保障</h3><ol><li>基于数据块传输</li><li>对数据包进行编号排序并按照序号去重</li><li>校验和，验证数据是否被篡改</li><li>重传机制，没有收到ACK的包会重传</li></ol><ul><li>超时重传：指定时间没没有收到ACK就重传</li><li>快速重传：收到连续三个ACK就重传，问题：重传一个还是重传所有的</li><li>SACK：在快速重传机制上加上SACK，表示已经收到数据信息，这样就只需要重传丢失的即可</li><li>D-SACK：可以告诉发送方哪些包是重复发送的</li></ul><ol start="5"><li>流量控制，利用滑动窗口实现</li></ol><ul><li>窗口数据分为四个部分</li><li>窗口大小由接收方决定，两端共同维护</li></ul><ol start="6"><li>拥塞控制</li></ol><ul><li>避免发送方的数据填满整个网络</li><li>发送方维护</li><li>发送窗口等于拥塞窗口和接收窗口的最小值</li><li>四个算法<ul><li>慢启动：当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1，指数级别的</li><li>拥塞避免：每轮拥塞窗口数量增加1</li><li>拥塞发生：使用超时重传和快速重传机制</li><li>快速恢复：问到就死</li></ul></li></ul><p><a href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0">4.2 TCP 重传、滑动窗口、流量控制、拥塞控制</a></p><h3 id="半包和粘包"><a href="#半包和粘包" class="headerlink" title="半包和粘包"></a>半包和粘包</h3><p>粘包：指数据在传输时，在一条消息中读取到了另一条消息的部分数据，这种现象就叫做粘包<br>半包：接收端只收到了部分数据，而非完整的数据的情况就叫做半包<br>为什么：因为 TCP 是面向连接的传输协议，它是以“流”的形式传输数据的，而“流”数据是没有明确的开始和结尾边界的，所以就会出现粘包问题<br>解决方案：</p><ul><li>固定数据大小，如果数据不够就用字符填充</li><li>自定义请求协议：发送数据的大小 + 具体数据</li><li>通过特殊字符来表示流的边界</li></ul><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>ARP 协议解决了 IP 地址转 MAC 地址的一些问题<br><strong>IP地址和MAC地址</strong><br>MAC相当于一台设备的真正标识，它是不会变的，而IP地址则是告诉你这个设备的不重复位置，当设备更换网络时，IP也就会发生变化</p><h3 id="GET-POST"><a href="#GET-POST" class="headerlink" title="GET &amp; POST"></a>GET &amp; POST</h3><ul><li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</li><li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</li></ul><p>GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。<br>POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存。</p><h3 id="session-cookie"><a href="#session-cookie" class="headerlink" title="session &amp; cookie"></a>session &amp; cookie</h3><p>cookie：保存在客户端的一部分数据<br>session：用来表示服务器和客户端的会话状态（是谁在会话）<br>区别：</p><ol><li>Cookie 保存在客户端，Session 保存在服务器端</li><li>Cookie 可设置为长时间保持，Session 一般有效时间较短，客户端关闭或者 Session 超时都会失效</li><li>session的安全性要更好一些</li></ol><p>联系：</p><ol><li>可以使用cookie记录session的 SessionID，每次请求前会携带这个信息</li></ol>]]></content>
      
      
      <categories>
          
          <category> 八股 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八股 </tag>
            
            <tag> Java </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
